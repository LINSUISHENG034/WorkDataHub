name: "Mapping Loader Portability + Config Hardening"
description: |
  Enhance mapping_loader to resolve YAML seed locations in a portable way and support environment override. 
  Optionally validate data_sources.yml in orchestration for fail-fast behavior with clear errors.

---

## Goal
Make the mapping loader system portable across execution contexts and harden configuration usage without changing runtime behavior. Ensure tests cover environment overrides and path handling; keep EAST deprecated and avoid DB/network dependencies.

## Why
- **Portability**: Current mapping loader uses hardcoded repo-relative paths, breaking when invoked from different working directories
- **Configuration Flexibility**: Need environment override capability for different deployment contexts (dev/test/prod)
- **Fail-Fast Behavior**: Early validation of data_sources.yml prevents runtime failures with clearer error messages
- **Testing Reliability**: Tests must work regardless of working directory to prevent CI/CD issues

## What
Enhanced `mapping_loader.py` with:
- `get_mappings_dir()` function supporting `WDH_MAPPINGS_DIR` environment override
- All loader functions using portable path resolution 
- Comprehensive test coverage for portability and overrides
- Optional single validation call in `orchestration/ops.py`

### Success Criteria
- [ ] `mapping_loader` resolves paths via `get_mappings_dir()` and supports `WDH_MAPPINGS_DIR` override
- [ ] New tests cover portability scenarios (different working directories)
- [ ] New tests cover environment override scenarios (both valid and invalid paths)
- [ ] Optional validation call added to `orchestration/ops.py` with clear error logging
- [ ] All validation gates pass with new functionality

## All Needed Context

### Documentation & References
```yaml
# MUST READ - Include these in your context window
- file: src/work_data_hub/config/mapping_loader.py
  why: Current implementation patterns, error handling, MappingLoaderError class
  critical: Uses hardcoded paths like "src/work_data_hub/config/mappings/company_branch.yml"
  
- file: src/work_data_hub/config/schema.py  
  why: validate_data_sources_config function already exists for optional integration
  critical: Returns True on success, raises DataSourcesValidationError on failure

- file: tests/config/test_mapping_loader.py
  why: Existing test patterns with fixtures, monkeypatch, pytest.raises
  critical: Tests use known values like "内蒙"→"G31", "集合计划"→"QTAN001"
  
- file: src/work_data_hub/orchestration/ops.py
  why: Location for optional validation call integration
  critical: Has logger and existing import patterns to follow
```

### Current Codebase Structure
```bash
src/work_data_hub/config/
├── mapping_loader.py           # Target for enhancement
├── mappings/                   # YAML seed files directory
│   ├── company_branch.yml      # 内蒙→G31, 济南→G21, etc.
│   ├── default_portfolio_code.yml # 集合计划→QTAN001, etc.
│   ├── company_id_overrides_plan.yml # FP0001→614810477, etc.
│   └── business_type_code.yml  # 职年受托→ZNST, etc.
├── schema.py                   # Has validate_data_sources_config
└── data_sources.yml            # Config file to validate

tests/config/
├── test_mapping_loader.py      # Target for new tests
└── test_data_sources_schema.py # Existing validation tests
```

### Known Gotchas & Library Quirks
```python
# CRITICAL: Path(__file__).parent ensures module-relative paths work regardless of CWD
# CRITICAL: Environment variable validation must check both exists() AND is_dir()
# CRITICAL: os.chdir() in tests requires try/finally to restore original directory
# CRITICAL: monkeypatch.setenv() is the correct pytest pattern for env var testing
# CRITICAL: MappingLoaderError should include the problematic path in error message
# CRITICAL: Circular import risk - import validate_data_sources_config within function if needed
# CRITICAL: Existing YAML files have specific values tests expect - don't modify content
# CRITICAL: All loader functions must return Dict[str, str] as per existing contract
```

## Implementation Blueprint

### Data models and structure
No new data models needed. Existing `Dict[str, str]` return types and `MappingLoaderError` exception are sufficient.

### List of tasks to be completed in order

```yaml
Task 1:
MODIFY src/work_data_hub/config/mapping_loader.py:
  - ADD import for os at top of file
  - ADD get_mappings_dir() -> Path function after existing imports
  - PATTERN: Use Path(__file__).parent / "mappings" as default
  - PATTERN: Check env var WDH_MAPPINGS_DIR with proper validation
  - ERROR: Raise MappingLoaderError with clear message on invalid override

Task 2:
MODIFY src/work_data_hub/config/mapping_loader.py:
  - UPDATE load_company_branch() to use get_mappings_dir()
  - UPDATE load_default_portfolio_code() to use get_mappings_dir()  
  - UPDATE load_company_id_overrides_plan() to use get_mappings_dir()
  - UPDATE load_business_type_code() to use get_mappings_dir()
  - PATTERN: str(get_mappings_dir() / "filename.yml") for all paths

Task 3:
MODIFY tests/config/test_mapping_loader.py:
  - ADD test_module_relative_paths_portable() test function
  - ADD test_env_override_directory() test function  
  - ADD test_env_override_missing_dir() test function
  - PATTERN: Follow existing test class structure and naming conventions
  - PATTERN: Use monkeypatch for environment variable testing

Task 4 (Optional):
MODIFY src/work_data_hub/orchestration/ops.py:
  - ADD import for validate_data_sources_config and DataSourcesValidationError
  - ADD try/except block near top-level with validation call
  - PATTERN: Use logger.error() for validation failures before re-raising
  - PRESERVE: All existing behavior and imports
```

### Per task pseudocode

```python
# Task 1: get_mappings_dir() function
import os
from pathlib import Path

def get_mappings_dir() -> Path:
    """Get mappings directory with environment variable override support."""
    env_dir = os.environ.get("WDH_MAPPINGS_DIR")
    if env_dir:
        p = Path(env_dir)
        if not p.exists() or not p.is_dir():
            raise MappingLoaderError(f"WDH_MAPPINGS_DIR not found or not a directory: {env_dir}")
        return p
    return Path(__file__).parent / "mappings"

# Task 2: Updated loader functions
def load_company_branch() -> Dict[str, str]:
    """Load company branch name to code mapping."""
    return load_yaml_mapping(str(get_mappings_dir() / "company_branch.yml"))

# Task 3: Portability test pattern
def test_module_relative_paths_portable(tmp_path):
    """Test that loaders work when invoked from any working directory."""
    original_cwd = os.getcwd()
    try:
        os.chdir(tmp_path)  # Change to different directory
        mapping = load_company_branch()
        # Should still work - test known values from repo seeds
        assert "内蒙" in mapping
        assert mapping["内蒙"] == "G31"
    finally:
        os.chdir(original_cwd)  # CRITICAL: Always restore

# Task 3: Environment override test pattern  
def test_env_override_directory(tmp_path, monkeypatch):
    """Test that WDH_MAPPINGS_DIR override works with valid directory."""
    # Create temp mappings directory with minimal YAML
    temp_mappings = tmp_path / "mappings" 
    temp_mappings.mkdir()
    (temp_mappings / "company_branch.yml").write_text("test_key: test_value")
    
    monkeypatch.setenv("WDH_MAPPINGS_DIR", str(temp_mappings))
    
    mapping = load_company_branch()
    assert mapping["test_key"] == "test_value"  # Uses override, not repo

# Task 4: Optional validation call
def _load_valid_domains():
    # Add validation at function entry
    try:
        from ..config.schema import validate_data_sources_config, DataSourcesValidationError
        validate_data_sources_config()
    except DataSourcesValidationError as e:
        logger.error(f"data_sources.yml validation failed: {e}")
        raise
    # ... rest of function unchanged
```

### Integration Points
```yaml
ENVIRONMENT:
  - variable: WDH_MAPPINGS_DIR
  - validation: Must exist and be a directory if set
  - fallback: src/work_data_hub/config/mappings (module-relative)
  
TESTING:
  - approach: monkeypatch for environment variables
  - approach: tmp_path for temporary directories  
  - approach: os.chdir with try/finally for portability tests
  - coverage: Both override and fallback scenarios

OPTIONAL_VALIDATION:
  - location: src/work_data_hub/orchestration/ops.py
  - pattern: Import within function to avoid circular dependencies
  - behavior: Log error and re-raise, preserve all existing behavior
```

## Validation Loop

### Level 1: Syntax & Style
```bash
# Run these FIRST - fix any errors before proceeding
uv run ruff check src/ --fix
uv run mypy src/

# Expected: No errors. If errors, READ the error and fix.
```

### Level 2: Unit Tests
```bash
# Run focused tests for this feature
uv run pytest tests/config/test_mapping_loader.py -v

# Run broader config tests to ensure no regressions  
uv run pytest -v -k "(mapping_loader or data_sources_schema or orchestration) and not postgres"

# Expected: All tests pass. If failing, understand root cause and fix code.
```

### Level 3: Portability Verification
```bash
# Test from different working directory to prove portability
cd /tmp && uv run pytest E:/Projects/WorkDataHub/tests/config/test_mapping_loader.py::TestSpecificLoaderFunctions::test_load_company_branch_happy_path -v

# Expected: Test passes from any directory, proving CWD independence
```

## Final Validation Checklist
- [ ] All new and existing tests pass: `uv run pytest tests/config/test_mapping_loader.py -v`
- [ ] No linting errors: `uv run ruff check src/`
- [ ] No type errors: `uv run mypy src/`
- [ ] Portability test passes from different CWD
- [ ] Environment override tests pass with both valid and invalid paths
- [ ] Optional validation call works without breaking existing ops.py behavior
- [ ] Error messages are clear and actionable
- [ ] All known seed values still accessible (内蒙→G31, 集合计划→QTAN001, etc.)

---

## Anti-Patterns to Avoid
- ❌ Don't rely on os.getcwd() or relative paths from working directory
- ❌ Don't skip directory validation for environment override
- ❌ Don't modify existing YAML seed file contents that tests depend on
- ❌ Don't use try/except without finally when changing working directory  
- ❌ Don't create circular imports when adding validation to ops.py
- ❌ Don't change existing function signatures or return types
- ❌ Don't suppress errors - always provide actionable error messages

## Confidence Score: 9/10
This PRP provides comprehensive implementation context with:
- ✅ Exact code patterns and error handling approaches
- ✅ Specific test values and validation approaches  
- ✅ Clear task ordering and dependencies
- ✅ Executable validation gates with expected outcomes
- ✅ Known gotchas and anti-patterns identified
- ✅ Integration points clearly defined
- ⚠️ Minor risk: Optional ops.py validation requires careful import handling

The implementation should succeed in one pass with this level of detail and context.