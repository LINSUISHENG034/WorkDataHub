name: "EQC Client Integration - KISS Implementation"
description: |

## Purpose
Implement a minimal, production-ready EQC (Enterprise Query Center) HTTP client for company data enrichment following KISS/YAGNI principles. This provides direct API access for company name search and detail retrieval without over-engineering.

## Core Principles
1. **Context is King**: Include ALL necessary documentation, examples, and caveats
2. **Validation Loops**: Provide executable tests/lints the AI can run and fix
3. **Information Dense**: Use keywords and patterns from the codebase
4. **Progressive Success**: Start simple, validate, then enhance
5. **Global rules**: Follow all rules in CLAUDE.md

---

## Goal
Create a simple, reliable EQC client (`EQCClient`) that provides company search and detail retrieval capabilities with proper error handling, rate limiting, retries, and configuration management. No abstractions or multi-provider support - just a working client.

## Why
- **Business value**: Enable company data enrichment for financial reporting workflows
- **Integration**: Foundation for company ID resolution in trustee performance data
- **Problems solved**: Automated company name standardization and enrichment
- **KISS/YAGNI**: Avoid over-engineering while maintaining production quality

## What
A synchronous HTTP client with these capabilities:
- Search companies by name with structured results
- Retrieve detailed company information by ID
- Handle authentication, rate limiting, timeouts, and retries
- Proper error handling with custom exception types
- Configuration via environment variables
- Comprehensive logging without credential exposure

### Success Criteria
- [ ] `EQCClient.search_company(name)` returns List[CompanySearchResult]
- [ ] `EQCClient.get_company_detail(company_id)` returns CompanyDetail
- [ ] Error handling for 401/404/429/5xx/timeout with appropriate exceptions
- [ ] Rate limiting prevents API abuse
- [ ] Retry logic with exponential backoff for recoverable errors
- [ ] Unit tests with mocks achieving >90% coverage
- [ ] Optional integration tests with real API
- [ ] All validation gates pass (ruff, mypy, pytest)

## All Needed Context

### Documentation & References
```yaml
# MUST READ - Include these in your context window
- file: legacy/annuity_hub/crawler/eqc_crawler.py
  why: Shows actual EQC API endpoints, headers, response structure, and authentication pattern
  critical: Token header format, Referer requirement, response parsing

- file: src/work_data_hub/io/connectors/file_connector.py
  why: Error handling patterns, logging, configuration loading
  critical: Custom exception hierarchy, structured logging approach

- file: src/work_data_hub/config/settings.py
  why: Configuration patterns with pydantic-settings and WDH_ prefix
  critical: Environment variable handling, nested configuration

- file: src/work_data_hub/domain/annuity_performance/service.py
  why: Domain-specific exception patterns and service structure
  critical: Exception naming conventions and inheritance

- url: https://docs.python-requests.org/en/latest/user/advanced/#session-objects
  why: Best practices for requests.Session usage and connection pooling

- url: https://docs.pydantic.dev/2.5/concepts/models/
  why: Pydantic v2 model patterns for response validation
```

### Implementation-Facing Research Notes
Purpose: Consolidate HTTP client best practices and implementation decisions.

```yaml
sources:
  - topic: Python HTTP client patterns 2024/2025
    type: best_practices

tldr:
  - Use requests.Session for connection reuse and better performance
  - Implement simple time-window rate limiting for API protection
  - Exponential backoff with jitter prevents thundering herd problems
  - Custom exceptions provide better error handling than generic ones
  - Structured logging with credential sanitization is critical

setup_commands:
  - "# No new dependencies needed - requests already in pyproject.toml"
  - "# Add optional integration test marker to pytest"

api_decisions:
  - name: HTTP library choice
    choice: requests (not httpx)
    rationale: Simple sync client, already in project, proven for this use case

  - name: Rate limiting strategy
    choice: Simple time-window tracking
    rationale: EQC has per-minute limits, simple implementation, sufficient for MVP

  - name: Retry strategy
    choice: Exponential backoff with jitter
    rationale: Standard pattern, prevents API overload, handles transient failures

  - name: Session management
    choice: requests.Session with connection pooling
    rationale: Better performance, proper timeout handling, follows best practices

versions:
  - library: requests
    constraint: "already in pyproject.toml"
    compatibility: "python 3.10+, existing project dependencies"

  - library: pydantic
    constraint: "v2 (existing)"
    compatibility: "already configured in project"

pitfalls_and_mitigations:
  - issue: Token exposure in logs
    mitigation: Sanitize all log messages, never log full headers or URLs with tokens

  - issue: Chinese character URL encoding
    mitigation: Use urllib.parse.quote() for query parameters

  - issue: Rate limit exceeded (429)
    mitigation: Implement request tracking and exponential backoff with max attempts

  - issue: Token expiry (401)
    mitigation: Clear error message directing user to refresh WDH_EQC_TOKEN

  - issue: Response field name mismatches
    mitigation: Explicit field mapping from EQC response to Pydantic models

open_questions:
  - None - specifications are clear from INITIAL.S-002.md
```

### Current Codebase tree
```bash
src/work_data_hub/
├── config/
│   ├── settings.py              # Configuration patterns to follow
│   └── data_sources.yml
├── io/
│   ├── connectors/
│   │   └── file_connector.py    # Error handling patterns to mirror
│   ├── readers/
│   └── loader/
├── domain/
│   ├── annuity_performance/
│   │   ├── models.py           # Pydantic model patterns
│   │   └── service.py          # Exception patterns to follow
└── utils/
    └── types.py

legacy/annuity_hub/
└── crawler/
    └── eqc_crawler.py          # API patterns and authentication
```

### Desired Codebase tree with files to be added
```bash
src/work_data_hub/
├── config/
│   ├── settings.py              # MODIFY: Add EQC configuration fields
│   └── data_sources.yml
├── io/
│   ├── connectors/
│   │   ├── file_connector.py
│   │   └── eqc_client.py        # CREATE: Main EQC client implementation
│   ├── readers/
│   └── loader/
├── domain/
│   ├── company_enrichment/      # CREATE: New domain for company data
│   │   ├── models.py            # CREATE: EQC data models
│   │   └── __init__.py          # CREATE: Package init
│   ├── annuity_performance/
│   └── __init__.py
└── utils/

tests/
├── io/
│   ├── connectors/
│   │   └── test_eqc_client.py   # CREATE: Comprehensive unit tests
└── domain/
    └── company_enrichment/
        └── test_models.py       # CREATE: Model validation tests
```

### Known Gotchas & Library Quirks
```python
# CRITICAL: EQC API requires specific headers - token NOT in Authorization header
# Headers must include: 'token': <token>, 'Referer': 'https://eqc.pingan.com/'

# CRITICAL: Chinese characters need URL encoding using urllib.parse.quote()
# Example: "中国平安" -> "%E4%B8%AD%E5%9B%BD%E5%B9%B3%E5%AE%89"

# CRITICAL: EQC API endpoints from legacy code:
# Search: GET /kg-api-hfd/api/search/searchAll?keyword=<encoded>&currentPage=1&pageSize=10
# Detail: GET /kg-api-hfd/api/search/findDepart?targetId=<company_id>

# CRITICAL: Rate limiting to prevent 429 errors - EQC has per-minute limits
# Must track request timestamps and enforce delays

# CRITICAL: Token expires every 30 minutes - provide clear error on 401
# Do NOT implement auto-refresh - that's out of scope per INITIAL.S-002.md

# CRITICAL: Response field mapping - EQC uses different names:
# companyId -> company_id, companyFullName -> official_name, unite_code -> unite_code

# CRITICAL: Logging must sanitize tokens and sensitive data
# Never log full headers, URLs with tokens, or response bodies with PII

# CRITICAL: Use pydantic v2 patterns consistently with project conventions
# Field validation, model_config, proper type hints
```

## Implementation Blueprint

### Data models and structure

```python
# src/work_data_hub/domain/company_enrichment/models.py
from pydantic import BaseModel, Field
from typing import List, Optional

class CompanySearchResult(BaseModel):
    """Result from EQC company search API."""
    company_id: str = Field(..., description="EQC company ID as string")
    official_name: str = Field(..., description="Official company name")
    unite_code: Optional[str] = Field(None, description="Unified social credit code")
    match_score: float = Field(0.0, ge=0.0, le=1.0, description="Search relevance score")

class CompanyDetail(BaseModel):
    """Detailed company information from EQC."""
    company_id: str = Field(..., description="EQC company ID as string")
    official_name: str = Field(..., description="Official company name")
    unite_code: Optional[str] = Field(None, description="Unified social credit code")
    aliases: List[str] = Field(default_factory=list, description="Alternative company names")
    business_status: Optional[str] = Field(None, description="Current business status")

# src/work_data_hub/io/connectors/eqc_client.py
class EQCClientError(Exception):
    """Base exception for EQC client errors."""
    pass

class EQCAuthenticationError(EQCClientError):
    """Raised when EQC authentication fails (401)."""
    pass

class EQCRateLimitError(EQCClientError):
    """Raised when rate limit exceeded and retries exhausted."""
    pass

class EQCNotFoundError(EQCClientError):
    """Raised when requested resource not found (404)."""
    pass
```

### List of tasks to be completed

```yaml
Task 1: Create Company Enrichment Domain Models
CREATE src/work_data_hub/domain/company_enrichment/__init__.py:
  - Empty package init file

CREATE src/work_data_hub/domain/company_enrichment/models.py:
  - PATTERN: Follow pydantic v2 patterns from existing domain models
  - Define CompanySearchResult with validation
  - Define CompanyDetail with optional fields
  - Use Field() with descriptions and constraints

Task 2: Update Configuration Settings
MODIFY src/work_data_hub/config/settings.py:
  - PATTERN: Follow existing WDH_ prefix convention
  - ADD eqc_enabled: bool = True
  - ADD eqc_timeout: int = 30
  - ADD eqc_rate_limit: int = 10  # requests per minute
  - ADD eqc_retry_max: int = 3
  - ADD eqc_base_url: str = "https://eqc.pingan.com"
  - PRESERVE existing configuration structure

Task 3: Implement EQC Client Core Structure
CREATE src/work_data_hub/io/connectors/eqc_client.py:
  - PATTERN: Mirror file_connector.py structure for imports and logging
  - Define custom exception hierarchy (4 classes)
  - Create EQCClient class with __init__ method
  - Setup requests.Session with proper headers
  - Implement rate limiting tracking mechanism

Task 4: Implement Rate Limiting and Request Helpers
MODIFY src/work_data_hub/io/connectors/eqc_client.py:
  - PATTERN: Simple time-window tracking with deque
  - Add _enforce_rate_limit() method
  - Add _make_request() helper with retry logic
  - Include exponential backoff with jitter
  - Handle timeout and HTTP errors appropriately

Task 5: Implement Company Search Method
MODIFY src/work_data_hub/io/connectors/eqc_client.py:
  - ADD search_company(name: str) -> List[CompanySearchResult]
  - PATTERN: URL encoding for Chinese characters
  - Parse API response and map to CompanySearchResult models
  - Handle empty results gracefully
  - Add structured logging with sanitization

Task 6: Implement Company Detail Method
MODIFY src/work_data_hub/io/connectors/eqc_client.py:
  - ADD get_company_detail(company_id: str) -> CompanyDetail
  - PATTERN: Similar error handling as search method
  - Parse businessInfodto response structure
  - Map response fields to CompanyDetail model
  - Handle missing optional fields safely

Task 7: Create Comprehensive Unit Tests
CREATE tests/io/connectors/test_eqc_client.py:
  - PATTERN: Follow existing test structure with fixtures
  - Mock requests.Session for isolated testing
  - Test success scenarios for both methods
  - Test all error conditions (401, 404, 429, 5xx, timeout)
  - Test rate limiting behavior
  - Test retry logic with exponential backoff
  - Achieve >90% code coverage

CREATE tests/domain/company_enrichment/test_models.py:
  - PATTERN: Follow pydantic model testing patterns
  - Test model validation and serialization
  - Test field constraints and defaults
  - Test error cases for invalid data

Task 8: Add Optional Integration Tests
MODIFY tests/io/connectors/test_eqc_client.py:
  - ADD integration test marked with @pytest.mark.eqc_integration
  - PATTERN: Skip if WDH_EQC_TOKEN not set
  - Test real API calls with minimal assertions
  - Focus on authentication and basic functionality
  - Document setup requirements

Task 9: Update Documentation
MODIFY README.md:
  - ADD "EQC Client Usage" section with code examples
  - Document environment variable requirements
  - Include setup instructions for integration tests
  - PRESERVE existing documentation structure
```

### Per task pseudocode

```python
# Task 3: EQC Client Core Structure
class EQCClient:
    def __init__(self, token: Optional[str] = None, *, timeout: int = 30,
                 retry_max: int = 3, rate_limit: int = 10):
        # PATTERN: Token priority from constructor or environment
        self.token = token or os.getenv("WDH_EQC_TOKEN")
        if not self.token:
            raise EQCAuthenticationError("EQC token required via parameter or WDH_EQC_TOKEN")

        # PATTERN: requests.Session for connection reuse
        self.session = requests.Session()
        self.session.headers.update({
            'token': self.token,
            'Referer': 'https://eqc.pingan.com/',
            'User-Agent': 'Mozilla/5.0 (WorkDataHub EQC Client)'
        })

        # Rate limiting: track request timestamps
        self.request_times = deque(maxlen=rate_limit)
        self.rate_limit = rate_limit
        self.timeout = timeout
        self.retry_max = retry_max

# Task 4: Rate Limiting and Request Helpers
def _enforce_rate_limit(self):
    # PATTERN: Simple sliding window rate limiting
    now = time.time()
    # Remove timestamps older than 60 seconds
    while self.request_times and self.request_times[0] <= now - 60:
        self.request_times.popleft()

    # If at limit, sleep until oldest request expires
    if len(self.request_times) >= self.rate_limit:
        sleep_time = 60 - (now - self.request_times[0]) + 0.1
        logger.debug(f"Rate limit reached, sleeping {sleep_time:.1f}s")
        time.sleep(sleep_time)

def _make_request(self, method: str, url: str, **kwargs):
    # PATTERN: Retry with exponential backoff
    for attempt in range(self.retry_max + 1):
        try:
            self._enforce_rate_limit()
            self.request_times.append(time.time())

            response = self.session.request(method, url, timeout=self.timeout, **kwargs)

            # Handle different status codes
            if response.status_code == 200:
                return response
            elif response.status_code == 401:
                raise EQCAuthenticationError("Invalid or expired EQC token")
            elif response.status_code == 404:
                raise EQCNotFoundError("Resource not found")
            elif response.status_code == 429:
                if attempt < self.retry_max:
                    # Exponential backoff with jitter
                    delay = (2 ** attempt) * (0.8 + 0.4 * random.random())
                    time.sleep(delay)
                    continue
                raise EQCRateLimitError("Rate limit exceeded, retries exhausted")
            elif response.status_code >= 500:
                if attempt < self.retry_max:
                    delay = (2 ** attempt) * (0.8 + 0.4 * random.random())
                    time.sleep(delay)
                    continue
                raise EQCClientError(f"Server error: {response.status_code}")

        except requests.RequestException as e:
            if attempt < self.retry_max:
                delay = (2 ** attempt) * (0.8 + 0.4 * random.random())
                time.sleep(delay)
                continue
            raise EQCClientError(f"Request failed: {e}")

# Task 5: Company Search Implementation
def search_company(self, name: str) -> List[CompanySearchResult]:
    # PATTERN: URL encoding for Chinese characters
    encoded_name = quote(name.strip(), safe='')
    url = f"{self.base_url}/kg-api-hfd/api/search/searchAll"
    params = {"keyword": encoded_name, "currentPage": 1, "pageSize": 10}

    logger.info("Searching companies", extra={"query": name, "encoded_length": len(encoded_name)})

    response = self._make_request("GET", url, params=params)
    data = response.json()

    # PATTERN: Parse EQC response structure from legacy code
    results = data.get("list", [])

    # Map to our models with field name conversion
    companies = []
    for item in results:
        company = CompanySearchResult(
            company_id=str(item.get("companyId", "")),
            official_name=item.get("companyFullName", ""),
            unite_code=item.get("unite_code"),
            match_score=0.9  # EQC doesn't provide scores, use default
        )
        companies.append(company)

    logger.info("Search completed", extra={"query": name, "results": len(companies)})
    return companies
```

### Integration Points
```yaml
ENVIRONMENT:
  - add to: .env
  - pattern: |
      # EQC Configuration
      WDH_EQC_ENABLED=true
      WDH_EQC_TOKEN=your_30min_token_here
      WDH_EQC_TIMEOUT=30
      WDH_EQC_RATE_LIMIT=10
      WDH_EQC_RETRY_MAX=3
      WDH_EQC_BASE_URL=https://eqc.pingan.com

CONFIG:
  - File: src/work_data_hub/config/settings.py
  - Pattern: Add new fields following existing WDH_ prefix convention
  - Integration: Use get_settings() pattern for dependency injection

TESTING:
  - Framework: pytest (existing)
  - Mocking: unittest.mock for requests
  - Coverage: pytest-cov for coverage reporting
  - Markers: @pytest.mark.eqc_integration for optional real API tests

LOGGING:
  - Pattern: Follow structured logging from file_connector.py
  - Critical: Sanitize all token and sensitive data
  - Level: INFO for operations, DEBUG for detailed flow, ERROR for failures
```

## Validation Loop

### Level 1: Syntax & Style
```bash
# Run these FIRST - fix any errors before proceeding
uv run ruff check src/ --fix         # Auto-fix style issues
uv run mypy src/                     # Type checking

# Expected: No errors. If errors exist, read and fix before proceeding.
```

### Level 2: Unit Tests
```python
# tests/io/connectors/test_eqc_client.py - Key test cases:

def test_client_initialization_with_token():
    """Test client initializes correctly with token."""
    client = EQCClient(token="test_token")
    assert client.token == "test_token"
    assert client.session.headers["token"] == "test_token"

def test_search_company_success(mock_session):
    """Test successful company search."""
    mock_response = Mock()
    mock_response.status_code = 200
    mock_response.json.return_value = {
        "list": [{"companyId": "123", "companyFullName": "Test Company"}]
    }
    mock_session.request.return_value = mock_response

    client = EQCClient("test_token")
    results = client.search_company("Test")

    assert len(results) == 1
    assert results[0].company_id == "123"
    assert results[0].official_name == "Test Company"

def test_authentication_error():
    """Test 401 authentication error handling."""
    client = EQCClient("invalid_token")
    with mock.patch.object(client.session, 'request') as mock_req:
        mock_req.return_value.status_code = 401

        with pytest.raises(EQCAuthenticationError):
            client.search_company("test")

def test_rate_limiting():
    """Test rate limiting prevents excessive requests."""
    client = EQCClient("test_token", rate_limit=2)

    # Fill rate limit
    client.request_times.extend([time.time(), time.time()])

    start_time = time.time()
    client._enforce_rate_limit()  # Should sleep
    elapsed = time.time() - start_time

    assert elapsed > 0.1  # Should have slept

def test_retry_with_exponential_backoff():
    """Test retry logic with proper backoff."""
    client = EQCClient("test_token", retry_max=2)

    with mock.patch.object(client.session, 'request') as mock_req:
        mock_req.side_effect = [
            Mock(status_code=500),  # First attempt fails
            Mock(status_code=500),  # Second attempt fails
            Mock(status_code=200, json=lambda: {"list": []})  # Third succeeds
        ]

        with mock.patch('time.sleep') as mock_sleep:
            client.search_company("test")

            # Verify exponential backoff was used
            assert mock_sleep.call_count == 2
            # First delay should be ~1s, second ~2s (with jitter)
            delays = [call[0][0] for call in mock_sleep.call_args_list]
            assert 0.8 <= delays[0] <= 1.4
            assert 1.6 <= delays[1] <= 2.8
```

```bash
# Run tests iteratively until passing:
uv run pytest tests/io/connectors/test_eqc_client.py -v
uv run pytest tests/domain/company_enrichment/ -v

# Check coverage:
uv run pytest tests/ --cov=src/work_data_hub/io/connectors/eqc_client --cov-report=term-missing

# Expected: >90% coverage, all tests passing
```

### Level 3: Integration Test
```bash
# Set up real token for integration testing:
export WDH_EQC_TOKEN=your_real_token_here

# Run integration tests:
uv run pytest tests/io/connectors/test_eqc_client.py::test_integration -m eqc_integration -v

# Expected interaction:
# - Real API call to EQC
# - Valid authentication
# - Structured response parsing
# - No rate limit violations

# Manual verification:
uv run python -c "
from src.work_data_hub.io.connectors.eqc_client import EQCClient
client = EQCClient()
results = client.search_company('中国平安')
if results:
    detail = client.get_company_detail(results[0].company_id)
    print(f'Found: {detail.official_name} ({detail.unite_code})')
else:
    print('No results found')
"

# Expected: Successful search and detail retrieval
```

## Final Validation Checklist
- [ ] All tests pass: `uv run pytest tests/ -v`
- [ ] No linting errors: `uv run ruff check src/`
- [ ] No type errors: `uv run mypy src/`
- [ ] Unit tests achieve >90% coverage
- [ ] Integration test passes with real token
- [ ] Rate limiting prevents API abuse
- [ ] Retry logic handles transient failures
- [ ] All error conditions raise appropriate exceptions
- [ ] Logging is structured and sanitized
- [ ] Configuration follows WDH_ prefix convention
- [ ] Data models validate correctly
- [ ] Manual verification successful

---

## Anti-Patterns to Avoid
- ❌ Don't hardcode API endpoints or tokens
- ❌ Don't ignore rate limits - implement proper throttling
- ❌ Don't skip retry logic for transient failures
- ❌ Don't expose tokens or credentials in logs
- ❌ Don't use bare exceptions - create specific exception types
- ❌ Don't skip input validation for Chinese characters
- ❌ Don't assume API response structure - validate with Pydantic
- ❌ Don't implement authentication refresh (out of scope)

## Confidence Score: 9/10

High confidence due to:
- Clear specifications from INITIAL.S-002.md
- Comprehensive legacy code analysis showing exact API patterns
- Existing codebase patterns to follow for configuration, errors, logging
- Well-defined validation gates with specific test cases
- HTTP best practices research captured in implementation notes
- KISS/YAGNI approach avoiding over-engineering

Minor uncertainty only around exact EQC API response variations in production, but legacy code provides solid foundation and error handling covers edge cases.