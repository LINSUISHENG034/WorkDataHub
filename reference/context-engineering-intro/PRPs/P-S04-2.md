name: "P-S04-2: Regression Recovery - Annuity Performance Backward Compatibility & Plan-Only Execution"
description: |

## Purpose
Restore S-004 to Definition-of-Done by fixing two critical regressions: annuity_performance service backward compatibility and plan-only execution database connection issues. This PRP provides comprehensive context for one-pass implementation success.

## Core Principles
1. **Context is King**: Include ALL necessary documentation, examples, and caveats
2. **Validation Loops**: Provide executable tests/lints the AI can run and fix
3. **Information Dense**: Use keywords and patterns from the codebase
4. **Progressive Success**: Start simple, validate, then enhance

---

## Goal
Fix annuity_performance regressions to restore backward compatibility and proper plan-only execution without breaking existing functionality or introducing new dependencies.

## Why
- **Business Value**: Restore working CI/CD pipeline and enable safe plan-only validation
- **Integration**: Maintain existing API contracts while providing enrichment metadata
- **Problems Solved**: Eliminate test failures and plan-only connection issues

## What
1. Restore `process()` function backward compatibility (returns `List[AnnuityPerformanceOut]`)
2. Make enrichment setup respect plan-only execution mode
3. Ensure proper database connection cleanup in all execution paths
4. Maintain enrichment functionality for orchestration layer

### Success Criteria
- [ ] All existing tests pass without modification
- [ ] `process([])` returns `[]` not a custom object
- [ ] Plan-only runs complete without database connections or psycopg2 imports
- [ ] Execute mode properly closes enrichment connections
- [ ] Orchestration can still access enrichment metadata

## All Needed Context

### Documentation & References
```yaml
# MUST READ - Include these in your context window
- file: src/work_data_hub/domain/annuity_performance/service.py
  why: Current broken implementation that needs backward compatibility fix

- file: tests/domain/annuity_performance/test_service.py
  why: Existing test expectations that must remain unchanged
  lines: 155-158,170,182,217,243

- file: src/work_data_hub/orchestration/ops.py
  why: load_op shows correct plan-only connection management pattern
  lines: 517-627

- file: src/work_data_hub/orchestration/ops.py
  why: process_annuity_performance_op current broken implementation
  lines: 256-384

- file: docs/INITIAL.md
  why: Complete requirements specification and acceptance criteria
  lines: 1-98

- file: CLAUDE.md
  why: Project conventions, error handling, and validation requirements
```

### Implementation-Facing Research Notes
```yaml
sources:
  - pattern: src/work_data_hub/orchestration/ops.py:load_op (lines 517-627)
    section: Connection management and plan-only patterns
    why: Exact pattern to replicate for enrichment service setup
    type: codebase

tldr:
  - load_op shows correct plan-only connection management pattern
  - Use wrapper function approach to maintain backward compatibility
  - Guard all database operations behind `not config.plan_only`
  - Always cleanup connections in finally blocks
  - Lazy import psycopg2 only when needed

api_decisions:
  - name: backward_compatible_wrapper
    choice: "process() calls process_with_enrichment() and returns .records"
    rationale: "Maintains exact existing API while enabling enrichment metadata access"

  - name: plan_only_detection
    choice: "Add plan_only field to ProcessingConfig"
    rationale: "Matches existing pattern in LoadConfig and other configs"

versions:
  - library: psycopg2
    constraint: "optional dependency, lazy import only"
    compatibility: "Must handle ImportError gracefully in plan-only mode"

pitfalls_and_mitigations:
  - issue: "Breaking existing test expectations"
    mitigation: "Keep exact function signature and return type for process()"

  - issue: "Connection leaks in error scenarios"
    mitigation: "Use try/finally blocks like load_op pattern"

  - issue: "psycopg2 import failures in plan-only"
    mitigation: "Guard all imports behind plan_only checks"

open_questions:
  - "Should process_with_enrichment be exported in __init__.py?"
  - "How to handle partial enrichment setup failures?"
```

### Current Codebase tree (focused on affected areas)
```bash
src/work_data_hub/
  domain/
    annuity_performance/
      __init__.py              # May need export updates
      models.py               # ProcessingResultWithEnrichment defined here
      service.py              # REGRESSION: process() return type changed
  orchestration/
    ops.py                    # REGRESSION: process_annuity_performance_op ignores plan_only
    jobs.py                   # CLI config → run_config wiring needs plan_only

tests/
  domain/annuity_performance/
    test_service.py           # CRITICAL: These tests must pass unchanged
  orchestration/
    test_ops.py              # Needs plan-only behavior tests added
```

### Known Gotchas & Library Quirks
```python
# CRITICAL: Existing tests expect exact return types
assert process([]) == []  # Must return list, not ProcessingResultWithEnrichment

# CRITICAL: psycopg2 import must be lazy and guarded
# Pattern from load_op shows proper handling:
if not config.plan_only:
    global psycopg2
    if psycopg2 is _PSYCOPG2_NOT_LOADED:
        try:
            import psycopg2 as _psycopg2
            psycopg2 = _psycopg2
        except ImportError:
            raise DataWarehouseLoaderError("psycopg2 not available")

# CRITICAL: Always cleanup connections in finally blocks
conn = None
try:
    if not config.plan_only:
        conn = psycopg2.connect(dsn)
        # ... setup enrichment
finally:
    if conn is not None:
        conn.close()
```

## Implementation Blueprint

### Data models and structure

The existing models are sufficient - no changes needed:
```python
# models.py already has:
# - AnnuityPerformanceOut: the return type for backward compatibility
# - ProcessingResultWithEnrichment: container with enrichment metadata
# - EnrichmentStats: statistics about enrichment operations
```

### List of tasks to be completed to fulfill the PRP in order

```yaml
Task 1: Restore Service Layer Backward Compatibility
MODIFY src/work_data_hub/domain/annuity_performance/service.py:
  - FIND: "def process(" function definition (line ~108)
  - RENAME current function to "process_with_enrichment"
  - CREATE new "process" wrapper that calls process_with_enrichment and returns .records
  - PRESERVE all existing parameters and behavior
  - ENSURE process([]) returns [] not ProcessingResultWithEnrichment

Task 2: Add Plan-Only Support to Processing Config
MODIFY src/work_data_hub/orchestration/ops.py:
  - FIND: "class ProcessingConfig" definition
  - ADD: plan_only: bool = True field
  - MIRROR pattern from LoadConfig

Task 3: Fix Orchestration Plan-Only Execution
MODIFY src/work_data_hub/orchestration/ops.py process_annuity_performance_op:
  - GUARD enrichment setup behind "if not config.plan_only and config.enrichment_enabled:"
  - MOVE psycopg2 import inside the guard block
  - ADD proper connection cleanup in finally block
  - CALL process_with_enrichment internally but serialize only .records field

Task 4: Wire CLI Plan-Only Flag to Config
MODIFY src/work_data_hub/orchestration/jobs.py:
  - FIND build_run_config functions
  - ADD plan_only field to ProcessingConfig initialization
  - USE existing effective_plan_only logic pattern

Task 5: Update Exports if Needed
MODIFY src/work_data_hub/domain/annuity_performance/__init__.py:
  - IF process_with_enrichment should be exported: ADD to __all__
  - ENSURE process remains exported for backward compatibility

Task 6: Add Plan-Only Tests
MODIFY tests/orchestration/test_ops.py:
  - ADD test for plan-only mode skipping enrichment setup
  - ADD test for execute mode connection cleanup
  - MIRROR existing test patterns from TestProcessTrusteePerformanceOp
```

### Per task pseudocode

```python
# Task 1: Service Layer Wrapper Pattern
def process(
    rows: List[Dict[str, Any]],
    data_source: str = "unknown",
    enrichment_service: Optional["CompanyEnrichmentService"] = None,
    sync_lookup_budget: int = 0,
    export_unknown_names: bool = True,
) -> List[AnnuityPerformanceOut]:
    """BACKWARD COMPATIBLE: Returns list of processed records only."""
    result = process_with_enrichment(
        rows, data_source, enrichment_service, sync_lookup_budget, export_unknown_names
    )
    return result.records

def process_with_enrichment(...) -> ProcessingResultWithEnrichment:
    # RENAME current process function to this
    # KEEP all existing logic unchanged

# Task 3: Orchestration Pattern (following load_op)
@op
def process_annuity_performance_op(context, config, excel_rows, file_paths):
    enrichment_service = None
    conn = None

    try:
        # GUARD: Only setup enrichment in execute mode
        if not config.plan_only and config.enrichment_enabled:
            # Lazy import pattern from load_op
            global psycopg2
            if psycopg2 is _PSYCOPG2_NOT_LOADED:
                try:
                    import psycopg2 as _psycopg2
                    psycopg2 = _psycopg2
                except ImportError:
                    raise DataWarehouseLoaderError("psycopg2 not available")

            # Create connection only in execute mode
            dsn = settings.get_database_connection_string()
            conn = psycopg2.connect(dsn)

            # Setup enrichment service with connection
            enrichment_service = CompanyEnrichmentService(...)

        # Call service with enrichment metadata
        result = process_with_enrichment(
            excel_rows,
            data_source=file_path,
            enrichment_service=enrichment_service,
            sync_lookup_budget=config.enrichment_sync_budget,
            export_unknown_names=config.export_unknown_names,
        )

        # Serialize only the records for downstream compatibility
        return [record.model_dump(mode="json", by_alias=True) for record in result.records]

    finally:
        # CRITICAL: Always cleanup connection
        if conn is not None:
            conn.close()
```

### Integration Points
```yaml
CLI:
  - pattern: "Extend existing effective_plan_only logic in jobs.py"
  - add to ProcessingConfig: "plan_only field from CLI arguments"

DATABASE:
  - connection: "Only in execute mode (not config.plan_only)"
  - cleanup: "Always in finally blocks like load_op"

TESTS:
  - preserve: "All existing test expectations unchanged"
  - add: "Plan-only behavior validation tests"
```

## Validation Loop

### Level 1: Syntax & Style
```bash
# Run these FIRST - fix any errors before proceeding
uv run ruff check src/ --fix  # Auto-fix style issues
uv run mypy src/            # Type checking

# Expected: No errors. If errors, READ and fix.
```

### Level 2: Unit Tests (Critical - Must Pass Unchanged)
```bash
# These existing tests MUST pass without modification:
uv run pytest tests/domain/annuity_performance/test_service.py::TestProcess::test_process_empty_rows -v
uv run pytest tests/domain/annuity_performance/test_service.py::TestProcess::test_process_valid_chinese_row -v

# Full focused suites from INITIAL.md:
uv run pytest -k "annuity_performance and service" -v
uv run pytest tests/orchestration/test_ops.py::TestProcessAnnuityPerformanceOp -v

# Expected: All tests pass. If failing, the backward compatibility is broken.
```

### Level 3: Plan-Only Integration Tests
```python
# ADD these new test cases to validate plan-only behavior:

def test_process_annuity_performance_op_plan_only_no_connections():
    """Test plan-only mode doesn't create database connections."""
    context = build_op_context()
    config = ProcessingConfig(enrichment_enabled=True, plan_only=True)

    with patch("src.work_data_hub.orchestration.ops.psycopg2") as mock_psycopg2:
        result = process_annuity_performance_op(context, config, [], [])

        # Should not attempt database connection
        mock_psycopg2.connect.assert_not_called()

def test_process_annuity_performance_op_execute_mode_cleanup():
    """Test execute mode properly cleans up connections."""
    # Implementation to verify connection.close() called
```

```bash
# Run new tests:
uv run pytest tests/orchestration/test_ops.py -k "plan_only" -v
```

## Final Validation Checklist
- [ ] All existing tests pass: `uv run pytest -v`
- [ ] No linting errors: `uv run ruff check src/`
- [ ] No type errors: `uv run mypy src/`
- [ ] process([]) returns [] not an object
- [ ] Plan-only runs don't import psycopg2 or create connections
- [ ] Execute mode closes enrichment connections
- [ ] Enrichment metadata still available to orchestration

## Acceptance Criteria Verification

Test these exact scenarios from INITIAL.md:
```bash
# Plan-only should work without database:
uv run python -m src.work_data_hub.orchestration.jobs --domain annuity_performance --plan-only --max-files 1 --enrichment-enabled --enrichment-sync-budget 3

# Execute mode should cleanup connections:
uv run python -m src.work_data_hub.orchestration.jobs --domain annuity_performance --execute --mode append --max-files 1 --enrichment-enabled --enrichment-sync-budget 3
```

---

## Anti-Patterns to Avoid
- ❌ Don't change existing test expectations - they define the contract
- ❌ Don't create database connections in plan-only mode
- ❌ Don't skip connection cleanup in error scenarios
- ❌ Don't break enrichment functionality for orchestration
- ❌ Don't change function signatures of existing exported functions
- ❌ Don't import psycopg2 at module level or in plan-only paths

## Confidence Score: 9/10

High confidence due to:
- Clear patterns to follow from load_op implementation
- Existing test suite defines exact behavioral contract
- Comprehensive context about current regression points
- Detailed pseudocode following proven codebase patterns
- Specific validation gates from requirements document

Minor uncertainty around edge cases in enrichment service cleanup, but patterns from load_op provide strong guidance.