# S-003 — 基础缓存机制与核心服务

实现简化的2表缓存结构，集成内部映射和EQC查询，提供统一的company_id解析服务。

## FEATURE

实现CompanyEnrichmentService，整合内部映射查询和EQC外部查询，提供缓存机制和临时ID生成，支持异步查询请求管理。

## SCOPE

### In-scope
- 实现lookup_requests表管理（异步查询队列）
- 集成S-001映射查询和S-002 EQC查询的统一服务
- 实现优先级解析逻辑（内部优先，外部补充）
- 简化的临时ID生成（TEMP_序号递增）
- 查询结果缓存到company_mapping表
- CLI集成：支持同步查询和异步队列处理

### Non-goals
- 不实现复杂的置信度评分
- 不实现多Provider抽象
- 不实现复杂的临时ID加密
- 不做数据清洗和规范化（保持原样）

## CONTEXT SNAPSHOT

```bash
src/work_data_hub/
  domain/
    company_enrichment/
      models.py                    # 数据模型（扩展S-001）
      service.py                   # 核心服务类
      lookup_queue.py              # 查询队列管理
  io/
    loader/
      company_enrichment_loader.py # 缓存数据装载器
  orchestration/
    ops.py                         # 集成到主流程的ops
scripts/
  create_table/
    ddl/
      lookup_requests.sql          # 查询请求表DDL
```

## EXAMPLES

- Path: `src/work_data_hub/domain/annuity_performance/service.py` — 域服务模式参考
- Path: `src/work_data_hub/io/loader/warehouse_loader.py` — 数据装载参考
- Path: `src/work_data_hub/orchestration/ops.py` — ops集成参考

```python
# 参考域服务模式
class CompanyEnrichmentService:
    def __init__(self, mapping_service: CompanyMappingService, eqc_client: EQCClient):
        self.mapping_service = mapping_service
        self.eqc_client = eqc_client

    def resolve_company_id(self, plan_code: str, customer_name: str, account_name: str) -> CompanyIdResult:
        """统一的company_id解析入口"""
```

## DOCUMENTATION

- File: `src/work_data_hub/domain/annuity_performance/service.py` — 现有域服务参考
- File: `docs/company_id/simplified/S-001_Legacy映射迁移.md` — 映射查询依赖
- File: `docs/company_id/simplified/S-002_EQC客户端集成.md` — EQC查询依赖
- File: `CLAUDE.md` — 架构约定和错误处理模式

## INTEGRATION POINTS

### Data models（扩展S-001）
```python
from enum import Enum
from pydantic import BaseModel, Field
from typing import Optional, List

class ResolutionStatus(str, Enum):
    SUCCESS_INTERNAL = "success_internal"    # 内部映射命中
    SUCCESS_EXTERNAL = "success_external"    # EQC查询成功
    PENDING_LOOKUP = "pending_lookup"        # 进入异步队列
    TEMP_ASSIGNED = "temp_assigned"          # 分配临时ID
    FAILED = "failed"                        # 查询失败

class CompanyIdResult(BaseModel):
    company_id: str = Field(..., description="解析得到的company_id")
    status: ResolutionStatus
    source: str = Field(..., description="来源：internal/external/temp")
    match_details: Optional[str] = Field(None, description="匹配详情")

class LookupRequest(BaseModel):
    name: str = Field(..., max_length=255)
    normalized_name: str = Field(..., max_length=255)
    status: Literal["pending", "processing", "done", "failed"] = "pending"
    attempts: int = Field(0, ge=0)
    last_error: Optional[str] = Field(None)
    created_at: datetime = Field(default_factory=lambda: datetime.now(UTC))
    updated_at: datetime = Field(default_factory=lambda: datetime.now(UTC))
```

### Database（扩展S-001的DDL）
```sql
-- 查询请求队列表
CREATE TABLE enterprise.lookup_requests (
    id BIGSERIAL PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    normalized_name VARCHAR(255) NOT NULL,
    status VARCHAR(20) NOT NULL DEFAULT 'pending',
    attempts INTEGER NOT NULL DEFAULT 0,
    last_error TEXT,
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now()
);

CREATE INDEX idx_lookup_requests_status ON enterprise.lookup_requests (status, created_at);
CREATE INDEX idx_lookup_requests_normalized_name ON enterprise.lookup_requests (normalized_name);

-- 临时ID序号表
CREATE TABLE enterprise.temp_id_sequence (
    id BIGSERIAL PRIMARY KEY,
    last_number INTEGER NOT NULL DEFAULT 0,
    updated_at TIMESTAMPTZ DEFAULT now()
);
INSERT INTO enterprise.temp_id_sequence (last_number) VALUES (0);
```

### Config/ENV
```bash
# 服务开关
WDH_COMPANY_ENRICHMENT_ENABLED=1      # 启用enrichment服务
WDH_COMPANY_SYNC_LOOKUP_LIMIT=5       # 同步查询上限（每次处理）

# 队列处理配置
WDH_LOOKUP_QUEUE_BATCH_SIZE=50        # 队列批处理大小
WDH_LOOKUP_RETRY_MAX=3                # 最大重试次数
WDH_LOOKUP_RETRY_DELAY=300            # 重试延迟秒数
```

### Jobs/Events
- 扩展现有ops，集成company_id enrichment步骤
- 新增CLI命令：`--job process_lookup_queue` 处理异步队列

## DATA CONTRACTS

### 核心服务接口
```python
class CompanyEnrichmentService:
    def resolve_company_id(
        self,
        plan_code: Optional[str] = None,
        customer_name: Optional[str] = None,
        account_name: Optional[str] = None,
        sync_lookup_budget: int = 0
    ) -> CompanyIdResult:
        """
        统一的company_id解析，按优先级顺序：
        1. 内部映射查询（plan_code -> account -> name -> account_name）
        2. 同步EQC查询（受budget限制）
        3. 异步队列入队
        4. 临时ID分配
        """
```

### 优先级解析逻辑
```python
def _resolve_priority_order(self, plan_code: str, customer_name: str, account_name: str) -> CompanyIdResult:
    # Priority 1: Plan code mapping
    if plan_code:
        result = self.mapping_service.get_by_plan_code(plan_code)
        if result:
            return CompanyIdResult(company_id=result, status="success_internal", source="plan")

    # Priority 2: Account mapping
    # Priority 3: Customer name mapping
    # Priority 4: Account name mapping
    # Priority 5: EQC sync lookup (if budget available)
    # Priority 6: Queue for async lookup
    # Priority 7: Generate temp ID
```

### 临时ID生成（简化版本）
```python
def generate_temp_id(self) -> str:
    """生成简单的临时ID：TEMP_001, TEMP_002, ..."""
    with self.db_session() as session:
        # 原子操作更新序号
        result = session.execute(
            text("UPDATE enterprise.temp_id_sequence SET last_number = last_number + 1 RETURNING last_number")
        )
        number = result.scalar()
        return f"TEMP_{number:06d}"  # TEMP_000001格式
```

## GOTCHAS & LIBRARY QUIRKS

- 临时ID生成需要数据库级别的原子操作，避免并发冲突
- 异步队列状态更新需要考虑并发处理，使用乐观锁
- EQC查询失败时不应阻塞主流程，降级到临时ID
- 名称规范化需要处理中文字符、全角/半角、空格等
- PostgreSQL的SERIAL类型在高并发下可能跳号，需要注意
- 查询结果缓存时需要防止重复插入（UPSERT逻辑）

## IMPLEMENTATION NOTES

- 遵循现有域服务模式，保持纯函数和副作用分离
- 使用事务管理数据一致性
- 日志记录每个优先级的命中统计
- 异步队列处理支持批量操作，提高效率
- 名称规范化逻辑抽取为独立函数，方便测试
- 错误处理：区分可重试和不可重试错误

## VALIDATION GATES

```bash
uv run ruff check src/ --fix
uv run mypy src/
uv run pytest -v -k "test_company_enrichment"

# 集成测试
export WDH_DATABASE__URI=postgresql://user:pass@host:5432/db
export WDH_COMPANY_ENRICHMENT_ENABLED=1
uv run pytest -v tests/domain/company_enrichment/

# 端到端测试
uv run python -m src.work_data_hub.orchestration.jobs \
  --domain annuity_performance \
  --plan-only \
  --max-files 1 \
  --debug
```

## ACCEPTANCE CRITERIA

- [ ] 统一的company_id解析服务，支持5级优先级查询
- [ ] 内部映射命中率与legacy保持一致
- [ ] EQC同步查询受budget限制，不超时阻塞
- [ ] 异步队列可以正确入队和批量处理
- [ ] 临时ID生成唯一且递增，支持并发
- [ ] 查询结果正确缓存到company_mapping表
- [ ] 完整的错误处理和降级机制
- [ ] 性能：单次解析<500ms，批量处理>100条/分钟

## ROLLOUT & RISK

### Feature flags
- `WDH_COMPANY_ENRICHMENT_ENABLED=0` 默认关闭
- 支持部分启用：只启用内部映射，暂不启用EQC查询
- 渐进式预算控制：从小额同步查询开始

### Risk mitigation
- 降级策略：任何组件失败都不阻塞主流程
- 数据一致性：使用事务保证映射表和队列表一致
- 性能监控：记录每个优先级的响应时间
- 错误监控：统计EQC查询成功率和重试次数

### Migration path
1. Phase 1: 仅启用内部映射，验证性能
2. Phase 2: 小额度启用EQC同步查询
3. Phase 3: 启用异步队列处理
4. Phase 4: 根据效果调整预算和批次大小

## APPENDICES

### 单元测试示例
```python
def test_resolve_company_id_priority_order():
    """测试优先级顺序：plan_code优先于customer_name"""
    service = CompanyEnrichmentService(mapping_service, eqc_client)

    # 模拟映射数据
    mapping_service.get_by_plan_code.return_value = "614810477"
    mapping_service.get_by_customer_name.return_value = "608349737"

    result = service.resolve_company_id(
        plan_code="AN001",
        customer_name="测试企业",
        sync_lookup_budget=0
    )

    assert result.company_id == "614810477"  # plan_code优先
    assert result.status == ResolutionStatus.SUCCESS_INTERNAL
    assert result.source == "plan"

def test_temp_id_generation_concurrent():
    """测试临时ID并发生成的唯一性"""
    import threading

    service = CompanyEnrichmentService(mapping_service, eqc_client)
    results = []

    def generate():
        results.append(service.generate_temp_id())

    threads = [threading.Thread(target=generate) for _ in range(10)]
    for t in threads:
        t.start()
    for t in threads:
        t.join()

    assert len(set(results)) == 10  # 所有ID唯一
    assert all(id.startswith("TEMP_") for id in results)
```

### 查询队列处理示例
```python
def process_lookup_queue_batch():
    """批量处理查询队列"""
    queue_service = LookupQueueService()
    pending_requests = queue_service.get_pending_batch(batch_size=50)

    for request in pending_requests:
        try:
            results = eqc_client.search_company(request.normalized_name)
            if results:
                # 更新映射表和标记请求完成
                mapping_service.cache_external_result(request.name, results[0].company_id)
                queue_service.mark_done(request.id)
            else:
                queue_service.mark_failed(request.id, "No results found")
        except Exception as e:
            queue_service.mark_failed(request.id, str(e))
```