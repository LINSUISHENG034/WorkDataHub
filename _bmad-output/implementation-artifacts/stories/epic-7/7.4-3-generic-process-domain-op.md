# Story 7.4-3: Generic Process Domain Op

Status: done

<!-- Note: Validation is optional. Run validate-create-story for quality check before dev-story. -->

## Story

As a **developer**,
I want **a factory function that generates domain-specific Dagster ops dynamically**,
so that **adding new domains only requires registering them in a service registry instead of creating separate op functions**.

## Acceptance Criteria

1. **AC1: DOMAIN_SERVICE_REGISTRY Created**

   - Create `DOMAIN_SERVICE_REGISTRY: Dict[str, DomainServiceEntry]` in `orchestration/ops/pipeline_ops.py`
   - Each entry contains: `service_fn` (callable), `supports_enrichment` (bool), `domain_name` (str)
   - All 3 existing domains registered: `annuity_performance`, `annuity_income`, `sandbox_trustee_performance`

2. **AC2: process_domain_op Created**

   - Create generic `process_domain_op` that delegates to domain service based on config
   - Accept `ProcessDomainOpConfig` with domain name parameter
   - Lookup domain service from registry and invoke processing
   - Return standardized `List[Dict[str, Any]]` (JSON-serializable records)

3. **AC3: Backward Compatibility**

   - Existing domain-specific ops (`process_annuity_performance_op`, `process_annuity_income_op`, `process_sandbox_trustee_performance_op`) remain functional
   - Generic op can coexist with domain-specific ops during transition
   - No changes to existing job definitions required (optional migration path)

4. **AC4: Enrichment Support Preserved**

   - Generic op respects `supports_enrichment` flag from registry
   - `annuity_performance` enrichment logic preserved in service layer
   - `annuity_income` and `sandbox_trustee_performance` skip enrichment setup

5. **AC5: All Existing Tests Pass**
   - No behavioral changes - pure extensibility enhancement
   - CI pipeline green
   - Key test files: `tests/orchestration/test_ops.py`, `tests/orchestration/test_jobs.py`

## Tasks / Subtasks

- [x] Task 1: Design DomainServiceEntry dataclass (AC: 1)

  - [x] 1.1 Define `DomainServiceEntry` with fields: `service_fn`, `supports_enrichment`, `domain_name`
  - [x] 1.2 Add type hints and docstring explaining registry pattern
  - [x] 1.3 Document service function signature contract

- [x] Task 2: Create DOMAIN_SERVICE_REGISTRY dictionary (AC: 1)

  - [x] 2.1 Register all 3 domains with correct service functions
  - [x] 2.2 Map `annuity_performance` → `process_with_enrichment` (requires `eqc_config` param - see Interface Adaptation section)
  - [x] 2.3 Map `annuity_income` → `process_with_enrichment` (uses `sync_lookup_budget` param, no eqc_config)
  - [x] 2.4 Map `sandbox_trustee_performance` → `process` (minimal interface: rows + data_source only)

- [x] Task 3: Create ProcessDomainOpConfig (AC: 2)

  - [x] 3.1 Extend `ProcessingConfig` or create new config class
  - [x] 3.2 Add `domain: str` field for registry lookup
  - [x] 3.3 Retain enrichment-related fields for backward compatibility

- [x] Task 4: Implement process_domain_op function (AC: 2, 4)

  - [x] 4.1 Create generic `@op` decorated function
  - [x] 4.2 Lookup service from DOMAIN_SERVICE_REGISTRY
  - [x] 4.3 Handle enrichment setup conditionally based on registry entry
  - [x] 4.4 Standardize output format (List[Dict[str, Any]])
  - [x] 4.5 Add comprehensive error handling for unknown domains

- [x] Task 5: Add Unit Tests (AC: 5)

  - [x] 5.1 Test DOMAIN_SERVICE_REGISTRY structure and entries
  - [x] 5.2 Test process_domain_op with each registered domain
  - [x] 5.3 Test unknown domain error handling
  - [x] 5.4 Test enrichment flag propagation

- [x] Task 6: Verify Tests and CI (AC: 5)
  - [x] 6.1 Run `pytest tests/orchestration/` - all tests pass
  - [x] 6.2 Run full test suite - no regressions
  - [x] 6.3 Verify existing domain-specific ops still work

## Dev Notes

### ⚠️ Known Complexity: Service Interface Differences

**CRITICAL:** The three domain services have **incompatible interfaces** that the generic op must handle:

| Domain                        | Service Function            | Return Type                      | Key Parameters                                          |
| ----------------------------- | --------------------------- | -------------------------------- | ------------------------------------------------------- |
| `annuity_performance`         | `process_with_enrichment()` | `ProcessingResultWithEnrichment` | `eqc_config: EqcLookupConfig` (required for enrichment) |
| `annuity_income`              | `process_with_enrichment()` | `ProcessingResultWithEnrichment` | `sync_lookup_budget: int` (no eqc_config)               |
| `sandbox_trustee_performance` | `process()`                 | `List[TrusteePerformanceOut]`    | Minimal: `rows, data_source` only                       |

The generic op **cannot use a uniform call signature** - it must adapt parameters per domain.

### Interface Adaptation Strategy

The generic op should use service-specific parameter unpacking:

```python
# In process_domain_op:
if domain == "annuity_performance":
    # Pass eqc_config for enrichment support
    result = entry.service_fn(
        excel_rows,
        data_source=file_path,
        eqc_config=eqc_config,  # From ProcessDomainOpConfig
        enrichment_service=enrichment_service,
        export_unknown_names=config.export_unknown_names,
    )
elif domain == "annuity_income":
    # Uses sync_lookup_budget, not eqc_config
    result = entry.service_fn(
        excel_rows,
        data_source=file_path,
        sync_lookup_budget=config.enrichment_sync_budget,
        export_unknown_names=config.export_unknown_names,
    )
else:
    # sandbox_trustee_performance - minimal interface
    result = entry.service_fn(excel_rows, data_source=file_path)
```

### Enrichment Setup Reference

For enrichment setup when `entry.supports_enrichment and config.enrichment_enabled`, **REUSE the existing pattern** from `pipeline_ops.py:128-241`:

- **Database validation:** Lines 175-196 (missing settings check)
- **psycopg2 lazy loading:** Lines 161-169 (import guard pattern)
- **Service initialization:** Lines 228-241 (CompanyEnrichmentLoader, LookupQueue, EQCClient, EnrichmentObserver)
- **Connection cleanup:** Lines 355-358 (finally block)

**DO NOT reimplement** - extract or reference this existing code.

### Critical Architecture Decisions

1. **Registry Location**: Define in `orchestration/ops/pipeline_ops.py` alongside existing ops (co-location with JOB_REGISTRY pattern from Story 7.4-1)

2. **Service Function Contract**: All domain services must implement a consistent interface:

   ```python
   def process_fn(
       rows: List[Dict[str, Any]],
       data_source: str,
       **kwargs
   ) -> Union[List[Model], ProcessingResult]
   ```

3. **Staged Migration**: Generic op is additive - existing domain-specific ops remain. Jobs can be migrated incrementally in future stories if desired.

4. **Enrichment Handling**: Only `annuity_performance` currently supports enrichment. Generic op should conditionally setup enrichment infrastructure based on registry entry + runtime config.

### Scope Boundaries

> **IN SCOPE:**
>
> - Create DOMAIN_SERVICE_REGISTRY with 3 domains
> - Create generic `process_domain_op` that delegates to services
> - Preserve existing domain-specific ops (no removal)
>
> **OUT OF SCOPE:**
>
> - Migrating existing jobs to use generic op (optional future story)
> - Domain autodiscovery (Story 7.4-4)
> - Removing existing domain-specific ops
> - Changing domain service interfaces

### References

- [Sprint Change Proposal - Story 7.4-3](../sprint-change-proposal/sprint-change-proposal-2025-12-30-domain-registry-architecture.md#Story-7.4-3)
- [Story 7.4-1](7.4-1-job-registry-pattern.md) - JOB_REGISTRY pattern (reference implementation)
- [Story 7.4-2](7.4-2-config-driven-backfill-list.md) - Config-driven approach
- [Technical Debt Analysis](../../specific/multi-domain/new-domain-checklist.md#MD-003)

### Target Code Pattern

**DomainServiceEntry Dataclass:**

```python
from dataclasses import dataclass
from typing import Any, Callable, List, Dict, Optional

@dataclass(frozen=True)
class DomainServiceEntry:
    """Registry entry for a domain's processing service.

    Attributes:
        service_fn: Callable that processes rows and returns models/results
        supports_enrichment: Whether domain supports company enrichment
        domain_name: Human-readable domain name for logging
    """
    service_fn: Callable[[List[Dict[str, Any]], str], Any]
    supports_enrichment: bool = False
    domain_name: str = ""
```

**DOMAIN_SERVICE_REGISTRY:**

```python
from work_data_hub.domain.annuity_performance.service import (
    process_with_enrichment as ap_process,
)
from work_data_hub.domain.annuity_income.service import (
    process_with_enrichment as ai_process,
)
from work_data_hub.domain.sandbox_trustee_performance.service import (
    process as stp_process,
)

DOMAIN_SERVICE_REGISTRY: Dict[str, DomainServiceEntry] = {
    "annuity_performance": DomainServiceEntry(
        service_fn=ap_process,
        supports_enrichment=True,
        domain_name="Annuity Performance (规模明细)",
    ),
    "annuity_income": DomainServiceEntry(
        service_fn=ai_process,
        supports_enrichment=False,  # No EQC enrichment
        domain_name="Annuity Income (收入明细)",
    ),
    "sandbox_trustee_performance": DomainServiceEntry(
        service_fn=stp_process,
        supports_enrichment=False,
        domain_name="Sandbox Trustee Performance",
    ),
}
```

**ProcessDomainOpConfig:**

> **Note:** Extends existing `ProcessingConfig` (pipeline_ops.py:31-52) with `domain` field. Inherits enrichment fields for backward compatibility.

```python
from work_data_hub.infrastructure.enrichment import EqcLookupConfig

class ProcessDomainOpConfig(Config):
    """Configuration for generic domain processing op.

    Extends ProcessingConfig with domain selection. The eqc_lookup_config
    field is the Single Source of Truth (SSOT) for EQC behavior (Story 6.2-P17).
    """

    domain: str  # Domain key for registry lookup
    enrichment_enabled: bool = False
    enrichment_sync_budget: int = 0
    eqc_lookup_config: Optional[Dict[str, Any]] = None  # Serialized EqcLookupConfig
    export_unknown_names: bool = True
    plan_only: bool = True
    use_pipeline: Optional[bool] = None
```

**process_domain_op Implementation Sketch:**

```python
from work_data_hub.infrastructure.enrichment import EqcLookupConfig

@op
def process_domain_op(
    context: OpExecutionContext,
    config: ProcessDomainOpConfig,
    excel_rows: List[Dict[str, Any]],
    file_paths: List[str],
) -> List[Dict[str, Any]]:
    """
    Generic domain processing op that delegates to registered service.

    Looks up domain service from DOMAIN_SERVICE_REGISTRY and invokes
    processing with appropriate configuration. Handles interface differences
    between domain services (see Known Complexity section).
    """
    domain = config.domain
    entry = DOMAIN_SERVICE_REGISTRY.get(domain)

    if not entry:
        supported = ", ".join(sorted(DOMAIN_SERVICE_REGISTRY.keys()))
        raise ValueError(f"Unknown domain: {domain}. Supported: {supported}")

    file_path = file_paths[0] if file_paths else "unknown"

    # Enrichment setup (only if domain supports it AND enabled)
    # CRITICAL: Reuse pattern from pipeline_ops.py:128-241 (see Enrichment Setup Reference)
    enrichment_service = None
    conn = None
    if entry.supports_enrichment and config.enrichment_enabled and not config.plan_only:
        # ... setup enrichment_service, conn per pipeline_ops.py:128-241 ...
        pass

    try:
        # Interface adaptation (see Known Complexity section)
        if domain == "annuity_performance":
            # Rehydrate EqcLookupConfig from dict
            eqc_config = (
                EqcLookupConfig.from_dict(config.eqc_lookup_config)
                if config.eqc_lookup_config
                else EqcLookupConfig.disabled()
            )
            result = entry.service_fn(
                excel_rows,
                data_source=file_path,
                eqc_config=eqc_config,
                enrichment_service=enrichment_service,
                export_unknown_names=config.export_unknown_names,
            )
        elif domain == "annuity_income":
            result = entry.service_fn(
                excel_rows,
                data_source=file_path,
                sync_lookup_budget=config.enrichment_sync_budget,
                export_unknown_names=config.export_unknown_names,
            )
        else:
            # sandbox_trustee_performance - minimal interface
            result = entry.service_fn(excel_rows, data_source=file_path)

        # Normalize output to List[Dict[str, Any]]
        # ProcessingResultWithEnrichment has .records attribute
        if hasattr(result, 'records'):
            result_dicts = [
                record.model_dump(mode="json", by_alias=True, exclude_none=True)
                for record in result.records
            ]
        elif isinstance(result, list):
            # Direct model list (sandbox_trustee_performance)
            result_dicts = [
                model.model_dump(mode="json", by_alias=True, exclude_none=True)
                for model in result
            ]
        else:
            raise TypeError(f"Unexpected result type from {domain} service: {type(result)}")

        context.log.info(
            "Domain processing completed - domain: %s, input_rows: %s, output_records: %s",
            entry.domain_name,
            len(excel_rows),
            len(result_dicts),
        )

        return result_dicts
    finally:
        # CRITICAL: Always cleanup connection (per pipeline_ops.py:355-358)
        if conn is not None:
            conn.close()
```

### Files to Modify

| File                                | Lines         | Change Type | Description                                   |
| ----------------------------------- | ------------- | ----------- | --------------------------------------------- |
| `orchestration/ops/pipeline_ops.py` | After L51     | Add         | `DomainServiceEntry` dataclass                |
| `orchestration/ops/pipeline_ops.py` | After imports | Add         | `DOMAIN_SERVICE_REGISTRY` dict                |
| `orchestration/ops/pipeline_ops.py` | End           | Add         | `ProcessDomainOpConfig` + `process_domain_op` |
| `tests/orchestration/test_ops.py`   | New class     | Add         | Unit tests for registry and generic op        |

### Complexity Analysis

**Major Differences Between Domain Services:**

| Domain                        | Service Function            | Return Type                      | Enrichment | Notes                                |
| ----------------------------- | --------------------------- | -------------------------------- | ---------- | ------------------------------------ |
| `annuity_performance`         | `process_with_enrichment()` | `ProcessingResultWithEnrichment` | Yes        | Complex EQC lookup, needs eqc_config |
| `annuity_income`              | `process_with_enrichment()` | `ProcessingResultWithEnrichment` | No         | Uses sync_lookup_budget param        |
| `sandbox_trustee_performance` | `process()`                 | `List[TrusteePerformanceOut]`    | No         | Simplest, direct model list          |

**Service Interface Normalization Required:**

1. `sandbox_trustee_performance.process()` returns `List[TrusteePerformanceOut]`
2. `annuity_*.process_with_enrichment()` returns `ProcessingResultWithEnrichment` with `.records` attribute

The generic op must handle both patterns (see implementation sketch above).

### Testing Strategy

1. **Unit Tests**: Add tests for new registry and generic op

   - `tests/orchestration/test_ops.py` - registry structure tests (add new test class)
   - `tests/orchestration/test_ops.py` - generic op invocation tests

2. **Manual Validation**:

   ```bash
   # Test via existing job (no changes needed)
   uv run --env-file .wdh_env python -m work_data_hub.cli.etl \
     --domain annuity_performance --dry-run

   # Registry can be validated programmatically
   python -c "from work_data_hub.orchestration.ops import DOMAIN_SERVICE_REGISTRY; print(list(DOMAIN_SERVICE_REGISTRY.keys()))"
   ```

3. **Regression Check**:
   - `PYTHONPATH=src uv run --env-file .wdh_env pytest tests/ -v` - full suite must pass

### Issues Addressed

| Issue ID | Description                                                   | Status    |
| -------- | ------------------------------------------------------------- | --------- |
| MD-003   | Each domain requires dedicated `process_{domain}_op` function | ✅ Fixing |

### Previous Story Intelligence (Story 7.4-1 & 7.4-2)

From Story 7.4-1:

- `JobEntry` dataclass pattern with frozen=True for immutability
- JOB_REGISTRY placed after all job function definitions
- Registry can be imported at module level without circular import issues

From Story 7.4-2:

- Config-driven approach using `data_sources.yml` inheritance
- Safe defaults with `getattr(obj, 'field', default)` pattern
- Fallback strategies for missing config

**Key Learnings to Apply:**

- Follow JobEntry dataclass pattern for DomainServiceEntry
- Place registry after service imports to avoid NameError
- Use consistent error message formatting with sorted keys
- Consider lazy imports if circular dependency issues arise

### Git Intelligence

Recent Story 7.4-1 and 7.4-2 commits show:

- JOB_REGISTRY pattern successfully implemented
- Config-driven backfill working with inheritance
- Test patterns established for registry validation

## Dev Agent Record

### Agent Model Used

Claude 3.5 Sonnet (Antigravity Code Review Agent)

### Debug Log References

- Code Review: 2025-12-30T16:39-16:48 - H001 test mock patching fixed
- Tests: 16 passed, 0 failed after fix

### Completion Notes List

- All 5 ACs implemented and verified
- `DomainServiceEntry` dataclass defined at lines 32-59 in `pipeline_ops.py`
- `DOMAIN_SERVICE_REGISTRY` with 3 domains at lines 62-82
- `ProcessDomainOpConfig` at lines 474-504
- `process_domain_op` at lines 507-814 (Moved to `domain_processing.py`)
- 16 unit tests added in new test file, all passing
- Code Review identified and fixed test mock patching strategy issue (H001)

### File List

| File                                                       | Change Type | Description                                                                  |
| ---------------------------------------------------------- | ----------- | ---------------------------------------------------------------------------- |
| `src/work_data_hub/orchestration/ops/pipeline_ops.py`      | Modified    | Added `DomainServiceEntry`, `DOMAIN_SERVICE_REGISTRY`                        |
| `src/work_data_hub/orchestration/ops/domain_processing.py` | New         | Added `ProcessDomainOpConfig`, `process_domain_op` (moved from pipeline_ops) |
| `src/work_data_hub/orchestration/ops/__init__.py`          | Modified    | Added Re-exports for backward compatibility                                  |
| `tests/orchestration/test_ops_domain_registry.py`          | New         | 16 unit tests for registry pattern (structure, config, generic op)           |
| `docs/sprint-artifacts/sprint-status.yaml`                 | Modified    | Updated story status to done                                                 |
