# Story 7.6-14: Annual Cutover Implementation (年度切断逻辑)

Status: ready-for-dev

## At a Glance

| Attribute | Value |
|-----------|-------|
| **Goal** | Implement January 1st annual cutover logic for customer status reset |
| **Impact** | Enables accurate year-over-year strategic customer tracking |
| **Risk** | Medium (new function, affects all active records) |
| **Dependencies** | Story 7.6-15 (Ratchet Rule - should be done first) |
| **Priority** | P1 (Important for annual KPI tracking) |
| **Rollback** | Delete newly created records, restore valid_to on closed records |

## Story

As a **BI Analyst**,
I want **all customer contract records to be automatically reset on January 1st with new status_year**,
So that **I can accurately track "2025 strategic customers" vs "2026 strategic customers" separately**.

## Background

### Problem Statement

Per `docs/memories/战客身份定义与更新逻辑.md` - **Principle 1: Annual Cutover**:
- On January 1st, ALL current records must be closed (regardless of status change)
- New records must be created with `status_year = current year`
- Purpose: Distinguish "2024 strategic customers" from "2025 strategic customers"

### Current Gap

**Data Evidence**: Query `WHERE EXTRACT(DAY FROM valid_from) = 1 AND EXTRACT(MONTH FROM valid_from) = 1` returns **0 records**.

All `valid_from` dates are month-end dates (28/29/30/31), indicating no annual cutover has ever been executed:

| Day of Month | Record Count |
|--------------|--------------|
| 28 | 431 |
| 29 | 55 |
| 30 | 6,318 |
| 31 | 13,078 |
| **1** | **0** |

### Business Impact

Without annual cutover:
- Cannot distinguish "2024 strategic customers" from "2025 strategic customers"
- Historical data may be polluted by future rule changes
- KPI calculations (e.g., "年初战客流失率") are inaccurate

## Acceptance Criteria

### AC-1: Annual Cutover Function

- Implement `annual_cutover(year: int)` function in `year_init.py`
- Function closes ALL current records (`valid_to = 'YYYY-01-01'`)
- Function inserts new records for all active customers with `status_year = year`

### AC-2: Record Closure

- All records with `valid_to = '9999-12-31'` are updated to `valid_to = 'YYYY-01-01'`
- `updated_at` timestamp is set to current time

### AC-3: New Record Creation

- New records have `valid_from = 'YYYY-01-01'`
- New records have `valid_to = '9999-12-31'`
- New records have `status_year = year` (input parameter)
- `is_strategic` and `is_existing` are recalculated based on prior year data

### AC-4: Idempotency

- Running cutover multiple times for same year produces identical results
- No duplicate records created

### AC-5: CLI Support

- Add CLI command: `uv run python -m work_data_hub.cli customer-mdm cutover --year 2026`
- Command logs progress and record counts

### AC-6: Validation

- After cutover, query for `valid_from` on January 1st returns > 0 records
- All customers with prior year activity have new records

## Tasks / Subtasks

- [ ] Task 1: Implement Annual Cutover Function (AC: 1, 2, 3)
  - [ ] Add `annual_cutover(year: int)` to `year_init.py`
  - [ ] Create SQL file `sql/annual_cutover_close.sql`
  - [ ] Create SQL file `sql/annual_cutover_insert.sql`
  - [ ] Ensure transaction safety

- [ ] Task 2: Recalculate Strategic Status (AC: 3)
  - [ ] Query prior year December data
  - [ ] Apply whitelist_top_n and strategic_threshold rules
  - [ ] Set is_existing based on prior year presence

- [ ] Task 3: Add CLI Command (AC: 5)
  - [ ] Add `cutover` subcommand to `cli/customer_mdm/`
  - [ ] Accept `--year` parameter (required)
  - [ ] Add `--dry-run` mode for safety

- [ ] Task 4: Add Unit Tests (AC: 4)
  - [ ] `test_annual_cutover_closes_all_records()`
  - [ ] `test_annual_cutover_creates_new_records()`
  - [ ] `test_annual_cutover_idempotency()`

- [ ] Task 5: Integration Test (AC: 6)
  - [ ] Run cutover for test year
  - [ ] Verify January 1st records exist

## Dev Notes

### Architecture Compliance

- **Follows SCD Type 2 Pattern** from Story 7.6-12
- **SQL File Pattern**: SQL in `src/work_data_hub/customer_mdm/sql/` directory
- **Business Rule Source**: `docs/memories/战客身份定义与更新逻辑.md`

### Python Implementation

```python
def annual_cutover(year: int, dry_run: bool = False) -> dict:
    """Execute annual cutover for customer_plan_contract.

    Business Rule (Principle 1 - 年度切断):
    1. Close all current records (valid_to = 'YYYY-01-01')
    2. Insert new records with status_year = year

    Args:
        year: The new status year (e.g., 2026)
        dry_run: If True, rollback changes after counting

    Returns:
        dict with 'closed_count' and 'inserted_count'
    """
    cutover_date = f"{year}-01-01"

    with get_connection() as conn:
        closed_count = _execute_close_records(conn, cutover_date)
        inserted_count = _execute_insert_new_records(conn, year)

        if dry_run:
            conn.rollback()
        else:
            conn.commit()

    return {"closed_count": closed_count, "inserted_count": inserted_count}
```

### SQL: Close Records

**File**: `sql/annual_cutover_close.sql`

```sql
UPDATE customer.customer_plan_contract
SET valid_to = :cutover_date::date,
    updated_at = CURRENT_TIMESTAMP
WHERE valid_to = '9999-12-31'
RETURNING contract_id;
```

### SQL: Insert New Records

**File**: `sql/annual_cutover_insert.sql`

```sql
WITH prior_year_dec AS (
    SELECT DISTINCT company_id, 计划代码, 产品线代码
    FROM business.规模明细
    WHERE EXTRACT(YEAR FROM 月度) = :year - 1
      AND EXTRACT(MONTH FROM 月度) = 12
      AND company_id IS NOT NULL
      AND 期末资产规模 > 0
),
strategic_whitelist AS (
    SELECT company_id, 计划代码, 产品线代码
    FROM (
        SELECT company_id, 计划代码, 产品线代码,
            SUM(期末资产规模) as total_aum,
            ROW_NUMBER() OVER (
                PARTITION BY 机构代码, 产品线代码
                ORDER BY SUM(期末资产规模) DESC
            ) as rank_in_branch
        FROM business.规模明细
        WHERE EXTRACT(YEAR FROM 月度) = :year - 1
          AND EXTRACT(MONTH FROM 月度) = 12
        GROUP BY company_id, 计划代码, 产品线代码, 机构代码
    ) ranked
    WHERE rank_in_branch <= :whitelist_top_n
       OR total_aum >= :strategic_threshold
)
-- Insert logic continues in implementation
```

### File Changes

| File | Change |
|------|--------|
| `src/work_data_hub/customer_mdm/year_init.py` | Add `annual_cutover()` |
| `src/work_data_hub/customer_mdm/sql/annual_cutover_close.sql` | New |
| `src/work_data_hub/customer_mdm/sql/annual_cutover_insert.sql` | New |
| `src/work_data_hub/cli/customer_mdm/cutover.py` | New CLI |
| `tests/unit/customer_mdm/test_year_init.py` | Add tests |

### CLI Usage

```bash
# Dry run (preview only)
uv run --env-file .wdh_env python -m work_data_hub.cli customer-mdm cutover \
  --year 2026 --dry-run

# Execute cutover
uv run --env-file .wdh_env python -m work_data_hub.cli customer-mdm cutover \
  --year 2026
```

### Validation SQL

```sql
-- Verify January 1st records exist
SELECT COUNT(*) as january_first_records
FROM customer.customer_plan_contract
WHERE EXTRACT(DAY FROM valid_from) = 1
  AND EXTRACT(MONTH FROM valid_from) = 1;
-- Expected: > 0 after cutover
```

### References

- [Source: docs/memories/战客身份定义与更新逻辑.md]
- [Source: docs/specific/customer-mdm/customer-plan-contract-implementation-gap-analysis.md]
- [Source: docs/sprint-artifacts/sprint-change-proposal/sprint-change-proposal-2026-02-05.md]

## Dev Agent Record

### Agent Model Used

{{agent_model_name_version}}

### Debug Log References

### Completion Notes List

### File List
