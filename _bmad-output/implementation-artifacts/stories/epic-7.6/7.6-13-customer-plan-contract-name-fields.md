# Story 7.6-13: Customer Plan Contract Name Fields Enhancement

Status: ready-for-dev

<!-- Note: Validation is optional. Run validate-create-story for quality check before dev-story. -->

## At a Glance

| Attribute | Value |
|-----------|-------|
| **Goal** | Add `customer_name` and `plan_name` redundant fields to `customer.customer_plan_contract` for query convenience |
| **Impact** | Low - Additive schema change, follows existing design pattern |
| **Risk** | Low - No breaking changes, nullable fields |
| **Dependencies** | None |
| **Priority** | P1 (Medium) |
| **Rollback** | Drop new columns, remove triggers |

## Story

As a **BI Developer / Data Analyst**,
I want **`customer.customer_plan_contract` to include `customer_name` and `plan_name` redundant fields**,
So that **I can query customer and plan names directly without JOIN operations, improving BI report readability and query convenience**.

## Background

### Problem Statement

The `customer.customer_plan_contract` table currently stores only ID/code references without human-readable names:

| Current Field | Type | Readable | Source |
|---------------|------|----------|--------|
| `company_id` | VARCHAR | ❌ ID only | `customer.年金客户` |
| `plan_code` | VARCHAR | ❌ Code only | `mapping.年金计划` |
| `product_line_code` | VARCHAR(20) | ❌ Code only | `mapping.产品线` |
| `product_line_name` | VARCHAR(50) | ✅ **Already redundant** | `mapping.产品线.产品线` |

This requires JOIN operations for every query that needs to display customer or plan names, reducing query convenience and BI report readability.

### Design Pattern Observation

The table **already uses `product_line_name` as a redundant field** for query convenience, establishing a precedent for denormalization. This enhancement follows the same proven pattern.

### Proposed Enhancement

Add two new redundant fields:

| New Field | Type | Source | Purpose |
|-----------|------|--------|---------|
| `customer_name` | VARCHAR(200) | `customer.年金客户.客户名称` | Display customer name |
| `plan_name` | VARCHAR(200) | `mapping.年金计划.计划全称` | Display plan full name |

## Acceptance Criteria

### AC-1: Schema Modification

- New columns `customer_name VARCHAR(200)` and `plan_name VARCHAR(200)` added to `customer.customer_plan_contract`
- Columns are nullable (NOT NULL constraint NOT required)
- Columns are indexed for query performance
- Alembic migration `008_create_customer_plan_contract.py` modified

### AC-2: Sync Triggers

- Trigger `trg_sync_contract_customer_name` created on `customer.年金客户.客户名称` UPDATE
- Trigger `trg_sync_contract_plan_name` created on `mapping.年金计划.计划全称` UPDATE
- Triggers use `IS DISTINCT FROM` for efficient change detection
- Triggers update `updated_at` timestamp on sync

### AC-3: Existing Data Population

- Existing records in `customer.customer_plan_contract` are backfilled with correct names
- Backfill SQL script created for existing databases
- All `customer_name` values populated from `customer.年金客户.客户名称`
- All `plan_name` values populated from `mapping.年金计划.计划全称`

### AC-4: Seed Data Export

- Seed data exported to `config/seeds/002/customer_plan_contract.dump`
- Export includes new `customer_name` and `plan_name` fields
- Seeds README updated with new field documentation

### AC-5: Sync Operations

- `sync_insert.sql` updated to include new fields in INSERT statement
- `seed_customer_plan_contract.py` updated to populate new fields
- All future sync operations populate new fields automatically

### AC-6: Documentation Update

- `customer-plan-contract-specification.md` updated with new fields
- Specification includes trigger design and sync logic
- Data flow diagram updated

## Tasks / Subtasks

- [ ] Task 1: Modify Alembic Migration Script (AC: 1)
  - [ ] Edit `io/schema/migrations/versions/008_create_customer_plan_contract.py`
  - [ ] Add `customer_name VARCHAR(200)` column definition
  - [ ] Add `plan_name VARCHAR(200)` column definition
  - [ ] Add indexes `idx_contract_customer_name` and `idx_contract_plan_name`
  - [ ] Add trigger function `sync_contract_customer_name()`
  - [ ] Add trigger function `sync_contract_plan_name()`
  - [ ] Add trigger `trg_sync_contract_customer_name` on `customer.年金客户`
  - [ ] Add trigger `trg_sync_contract_plan_name` on `mapping.年金计划`

- [ ] Task 2: Create SQL Script for Existing Database (AC: 1, 3)
  - [ ] Create `scripts/migrations/add_contract_name_fields.sql`
  - [ ] Add ALTER TABLE statements for new columns
  - [ ] Add UPDATE statements to backfill existing data
  - [ ] Add CREATE INDEX statements
  - [ ] Add CREATE FUNCTION statements for triggers
  - [ ] Add CREATE TRIGGER statements

- [ ] Task 3: Update Sync Operations (AC: 5)
  - [ ] Edit `src/work_data_hub/customer_mdm/sql/sync_insert.sql`
  - [ ] Add `customer_name` to INSERT statement (JOIN with `customer.年金客户`)
  - [ ] Add `plan_name` to INSERT statement (JOIN with `mapping.年金计划`)
  - [ ] Verify JOIN conditions are correct

- [ ] Task 4: Update Seed Script (AC: 5)
  - [ ] Edit `scripts/seed_data/seed_customer_plan_contract.py`
  - [ ] Add `customer_name` population logic
  - [ ] Add `plan_name` population logic
  - [ ] Test seed script execution

- [ ] Task 5: Export Seed Data (AC: 4)
  - [ ] Export updated `customer.customer_plan_contract` to `config/seeds/002/customer_plan_contract.dump`
  - [ ] Update `config/seeds/README.md` with new field documentation

- [ ] Task 6: Update Specification Document (AC: 6)
  - [ ] Edit `docs/specific/customer-mdm/customer-plan-contract-specification.md`
  - [ ] Add new fields to DDL section
  - [ ] Add trigger design documentation
  - [ ] Update data flow diagram
  - [ ] Update field descriptions table

- [ ] Task 7: Add Unit Tests (AC: 1, 2, 3)
  - [ ] Test new columns exist in schema
  - [ ] Test triggers fire on dimension updates
  - [ ] Test backfill SQL populates correct names
  - [ ] Test sync_insert.sql includes new fields

- [ ] Task 8: Integration Test (AC: 3, 5)
  - [ ] Run migration on test database
  - [ ] Verify existing records have names populated
  - [ ] Test sync operation creates records with names
  - [ ] Verify triggers update names on dimension changes

## Dev Notes

### Architecture Compliance

- **Follows Existing Pattern**: The `product_line_name` field already exists as a redundant field, establishing precedent
- **Database**: PostgreSQL (production), uses `IS DISTINCT FROM` for NULL-safe comparison
- **Schema Changes**: Must use Alembic migrations, direct DDL forbidden unless debugging
- **SQL File Pattern**: SQL files in `src/work_data_hub/customer_mdm/sql/` directory
- **Testing Standards**: Unit tests in `tests/unit/customer_mdm/`

### Project Structure Notes

```
src/work_data_hub/
├── customer_mdm/
│   ├── sql/
│   │   ├── sync_insert.sql           # MODIFY: Add new fields
│   │   └── close_old_records.sql     # No change needed
│   └── contract_sync.py              # No change needed
├── cli/
│   └── customer_mdm/                 # CLI commands
└── infrastructure/

io/schema/migrations/versions/
└── 008_create_customer_plan_contract.py  # MODIFY: Add columns + triggers

scripts/
├── migrations/
│   └── add_contract_name_fields.sql  # CREATE: For existing DB
└── seed_data/
    └── seed_customer_plan_contract.py   # MODIFY: Add field population

config/seeds/002/
└── customer_plan_contract.dump       # UPDATE: Export with new fields

docs/specific/customer-mdm/
└── customer-plan-contract-specification.md  # MODIFY: Document new fields
```

### Technical Requirements

#### New Columns DDL

```sql
-- Add to customer.customer_plan_contract
ALTER TABLE customer.customer_plan_contract
    ADD COLUMN customer_name VARCHAR(200),
    ADD COLUMN plan_name VARCHAR(200);

-- Add indexes
CREATE INDEX idx_contract_customer_name
    ON customer.customer_plan_contract(customer_name);
CREATE INDEX idx_contract_plan_name
    ON customer.customer_plan_contract(plan_name);
```

#### Trigger: Customer Name Sync

```sql
-- Function: Sync customer_name when 年金客户.客户名称 changes
CREATE OR REPLACE FUNCTION customer.sync_contract_customer_name()
RETURNS TRIGGER AS $$
BEGIN
    IF OLD.客户名称 IS DISTINCT FROM NEW.客户名称 THEN
        UPDATE customer.customer_plan_contract
        SET customer_name = NEW.客户名称,
            updated_at = CURRENT_TIMESTAMP
        WHERE company_id = NEW.company_id;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger
CREATE TRIGGER trg_sync_contract_customer_name
AFTER UPDATE OF 客户名称 ON customer."年金客户"
FOR EACH ROW
EXECUTE FUNCTION customer.sync_contract_customer_name();
```

#### Trigger: Plan Name Sync

```sql
-- Function: Sync plan_name when 年金计划.计划全称 changes
CREATE OR REPLACE FUNCTION customer.sync_contract_plan_name()
RETURNS TRIGGER AS $$
BEGIN
    IF OLD.计划全称 IS DISTINCT FROM NEW.计划全称 THEN
        UPDATE customer.customer_plan_contract
        SET plan_name = NEW.计划全称,
            updated_at = CURRENT_TIMESTAMP
        WHERE plan_code = NEW.年金计划号;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger
CREATE TRIGGER trg_sync_contract_plan_name
AFTER UPDATE OF 计划全称 ON mapping."年金计划"
FOR EACH ROW
EXECUTE FUNCTION customer.sync_contract_plan_name();
```

#### Backfill SQL for Existing Database

```sql
-- Backfill customer_name
UPDATE customer.customer_plan_contract cpc
SET customer_name = c.客户名称
FROM customer."年金客户" c
WHERE cpc.company_id = c.company_id
  AND cpc.customer_name IS NULL;

-- Backfill plan_name
UPDATE customer.customer_plan_contract cpc
SET plan_name = p.计划全称
FROM mapping."年金计划" p
WHERE cpc.plan_code = p.年金计划号
  AND cpc.plan_name IS NULL;
```

#### Updated sync_insert.sql

```sql
-- Add to INSERT statement
INSERT INTO customer.customer_plan_contract (
    company_id,
    plan_code,
    product_line_code,
    product_line_name,
    customer_name,    -- NEW
    plan_name,        -- NEW
    is_strategic,
    is_existing,
    status_year,
    contract_status,
    valid_from,
    valid_to
)
SELECT
    sb.company_id,
    sb.计划代码,
    sb.产品线代码,
    pl.产品线,
    c.客户名称,       -- NEW: JOIN with customer.年金客户
    p.计划全称,       -- NEW: JOIN with mapping.年金计划
    ...
FROM business.规模明细 sb
LEFT JOIN customer."年金客户" c ON sb.company_id = c.company_id
LEFT JOIN mapping."年金计划" p ON sb.计划代码 = p.年金计划号
...;
```

### Data Flow

```
┌─────────────────────┐                    ┌──────────────────────────────┐
│ customer.年金客户    │───(company_id)───→│ customer.customer_plan_contract │
│ (客户名称)          │    Trigger 1       │ (customer_name)               │
└─────────────────────┘                    └──────────────────────────────┘

┌─────────────────────┐                    ┌──────────────────────────────┐
│ mapping.年金计划     │───(年金计划号)───→│ customer.customer_plan_contract │
│ (计划全称)          │    Trigger 2       │ (plan_name)                   │
└─────────────────────┘                    └──────────────────────────────┘
```

### File Changes Summary

| File | Change Type | Description |
|------|-------------|-------------|
| `io/schema/migrations/versions/008_create_customer_plan_contract.py` | Modify | Add columns + triggers |
| `scripts/migrations/add_contract_name_fields.sql` | Create | ALTER existing database |
| `scripts/seed_data/seed_customer_plan_contract.py` | Modify | Add new fields population |
| `src/work_data_hub/customer_mdm/sql/sync_insert.sql` | Modify | Add new fields to INSERT |
| `docs/specific/customer-mdm/customer-plan-contract-specification.md` | Modify | Document new fields |
| `config/seeds/002/customer_plan_contract.dump` | Update | Export with new fields |
| `config/seeds/README.md` | Update | Document new fields |

### Testing Requirements

- **Unit Tests**: `tests/unit/customer_mdm/test_contract_sync.py`
  - Test schema has new columns
  - Test triggers fire on dimension updates
  - Test backfill SQL correctness
- **Integration Tests**: Run full sync and verify data

### Source Tables Reference

| Table | Key Field | Name Field | Records |
|-------|-----------|------------|---------|
| `customer.年金客户` | `company_id` | `客户名称` | ~10,436 |
| `mapping.年金计划` | `年金计划号` | `计划全称` | ~1,158 |

### Success Criteria

- [ ] New columns `customer_name` and `plan_name` added to schema
- [ ] Sync triggers created and functional
- [ ] Existing data populated correctly
- [ ] Seed data exported to `config/seeds/002/`
- [ ] All sync operations populate new fields
- [ ] Specification document updated
- [ ] All existing tests pass

### Recommended Implementation Order

1. Modify Alembic migration script (008)
2. Create SQL script for existing database ALTER
3. Update `sync_insert.sql` with new fields
4. Update `seed_customer_plan_contract.py`
5. Run ALTER script on existing database
6. Backfill existing records with names
7. Export seed data to `config/seeds/002/`
8. Update specification document

### References

- [Source: docs/sprint-artifacts/sprint-change-proposal/sprint-change-proposal-2026-02-05-contract-name-fields.md]
- [Source: docs/specific/customer-mdm/customer-plan-contract-specification.md]
- [Source: docs/project-context.md]

## Dev Agent Record

### Agent Model Used

{{agent_model_name_version}}

### Debug Log References

### Completion Notes List

### File List
