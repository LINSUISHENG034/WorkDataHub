# Story 7.6-18: Config-Driven Status Evaluation Framework

Status: done

## Story

As a **data engineer**,
I want **customer status evaluation rules to be defined in configuration files instead of hardcoded SQL**,
so that **business rules can be modified without code changes and the evaluation logic is transparent and auditable**.

## Acceptance Criteria

1. **Config File Created**: `config/customer_status_rules.yml` exists with schema version, source definitions, status definitions, and evaluation rules
2. **StatusEvaluator Class**: `src/work_data_hub/customer_mdm/status_evaluator.py` implements rule loading and evaluation
3. **Condition Types Supported**:
   - `exists_in_year` - Record exists within calendar year
   - `field_equals` - Field value equals specified value
   - `disappeared` - Record existed last period but not this period
   - `first_appearance` - First time appearing in source
4. **Operator Support**: AND/OR condition combinations work correctly
5. **Integration**: `snapshot_refresh.py` uses StatusEvaluator instead of hardcoded SQL for status derivation
6. **Backward Compatibility**: All existing status fields produce identical results after refactoring
7. **Logging**: Evaluation decisions are logged with structured context for audit trail

## Tasks / Subtasks

- [x] Task 1: Create config schema and file (AC: #1)
  - [x] 1.1 Define YAML schema for `customer_status_rules.yml`
  - [x] 1.2 Create config file with all 4 status definitions (is_winning_this_year, is_loss_reported, is_new_arrival, is_churned)
  - [x] 1.3 Add Pydantic model for config validation in `infrastructure/settings/`

- [x] Task 2: Implement StatusEvaluator class (AC: #2, #3, #4)
  - [x] 2.1 Create `status_evaluator.py` with config loading
  - [x] 2.2 Implement `exists_in_year` condition type
  - [x] 2.3 Implement `field_equals` condition type
  - [x] 2.4 Implement `disappeared` condition type (compare with previous period)
  - [x] 2.5 Implement `first_appearance` condition type
  - [x] 2.6 Implement AND/OR operator logic for condition combinations

- [x] Task 3: Integrate with snapshot_refresh.py (AC: #5, #6)
  - [x] 3.1 Refactor `_refresh_product_line_snapshot` to use StatusEvaluator
  - [x] 3.2 Refactor `_refresh_plan_snapshot` to use StatusEvaluator
  - [x] 3.3 Verify backward compatibility with existing data

- [x] Task 4: Add logging and testing (AC: #7)
  - [x] 4.1 Add structured logging for evaluation decisions
  - [x] 4.2 Write unit tests for StatusEvaluator
  - [x] 4.3 Write integration tests comparing old vs new results

## Dev Notes

### Architecture Pattern

This story follows the **Configuration-Driven Pattern** established in Decision #11 (Hybrid Reference Data Management). The goal is to externalize business rules from code to configuration.

**Current State (Hardcoded SQL in snapshot_refresh.py:98-149):**
```sql
-- is_winning_this_year: Hardcoded EXISTS subquery
EXISTS (
    SELECT 1 FROM customer.当年中标 w
    WHERE w.company_id = c.company_id
      AND w.产品线代码 = c.product_line_code
      AND EXTRACT(YEAR FROM w.上报月份) = %(snapshot_year)s
) as is_winning_this_year
```

**Target State (Config-driven):**
```yaml
# config/customer_status_rules.yml
is_winning_this_year:
  conditions:
    - type: exists_in_year
      source: annual_award
      year_field: 上报月份
      match_fields: [company_id, 产品线代码]
```

### Source Tree Components

| Component | Path | Action |
|-----------|------|--------|
| Config file | `config/customer_status_rules.yml` | CREATE |
| Config schema | `src/work_data_hub/infrastructure/settings/customer_status_schema.py` | CREATE |
| StatusEvaluator | `src/work_data_hub/customer_mdm/status_evaluator.py` | CREATE |
| Snapshot refresh | `src/work_data_hub/customer_mdm/snapshot_refresh.py` | MODIFY |
| Unit tests | `tests/unit/customer_mdm/test_status_evaluator.py` | CREATE |
| Integration tests | `tests/integration/customer_mdm/test_status_evaluation.py` | CREATE |

### Config File Schema

```yaml
# config/customer_status_rules.yml
schema_version: "1.0"

sources:
  annuity_performance:
    table: business."规模明细"
    key_fields: [company_id, product_line_code, snapshot_month]
  annual_award:
    table: customer."当年中标"
    key_fields: [company_id, 上报月份]
  annual_loss:
    table: customer."当年流失"
    key_fields: [company_id, 上报月份]

status_definitions:
  is_new_arrival:
    description: "新到账 - First appearance in 规模明细"
    source: annuity_performance
    time_scope: monthly
  is_churned:
    description: "已流失 - Disappeared or zero AUM"
    source: annuity_performance
    time_scope: monthly
  is_winning_this_year:
    description: "新中标 - Has award record this year"
    source: annual_award
    time_scope: yearly
  is_loss_reported:
    description: "申报流失 - Has loss report this year"
    source: annual_loss
    time_scope: yearly

evaluation_rules:
  is_winning_this_year:
    conditions:
      - type: exists_in_year
        year_field: 上报月份
        match_fields: [company_id, 产品线代码]

  is_loss_reported:
    conditions:
      - type: exists_in_year
        year_field: 上报月份
        match_fields: [company_id, 产品线代码]

  is_churned:
    operator: OR
    conditions:
      - type: disappeared
        compare_field: company_id
        scope: product_line_code
      - type: field_equals
        field: 期末资产规模
        value: 0
```

### StatusEvaluator Class Design

```python
# src/work_data_hub/customer_mdm/status_evaluator.py
from dataclasses import dataclass
from typing import Any
import yaml
from pydantic import BaseModel

class ConditionConfig(BaseModel):
    type: str  # exists_in_year, field_equals, disappeared, first_appearance
    # Type-specific fields...

class StatusRule(BaseModel):
    operator: str = "AND"  # AND or OR
    conditions: list[ConditionConfig]

class StatusEvaluator:
    """Config-driven status evaluation engine."""

    def __init__(self, config_path: str = "config/customer_status_rules.yml"):
        self.config = self._load_config(config_path)

    def evaluate(
        self,
        status_name: str,
        context: dict[str, Any],
        cursor: psycopg.Cursor,
    ) -> bool:
        """Evaluate a status rule against the given context."""
        rule = self.config.evaluation_rules[status_name]
        results = [
            self._evaluate_condition(cond, context, cursor)
            for cond in rule.conditions
        ]

        if rule.operator == "OR":
            return any(results)
        return all(results)

    def generate_sql_fragment(
        self,
        status_name: str,
        table_alias: str,
        params: dict[str, Any],
    ) -> str:
        """Generate SQL fragment for status evaluation.

        This allows the evaluator to be used in SQL queries
        while keeping the logic config-driven.
        """
        ...
```

### Testing Standards

1. **Unit Tests**: Test each condition type in isolation
2. **Integration Tests**: Compare results with current hardcoded implementation
3. **Golden Dataset**: Use existing snapshot data as baseline for regression testing

```python
# tests/unit/customer_mdm/test_status_evaluator.py
def test_exists_in_year_condition():
    """Test exists_in_year evaluates correctly."""
    ...

def test_or_operator_combines_conditions():
    """Test OR operator returns True if any condition is True."""
    ...

# tests/integration/customer_mdm/test_status_evaluation.py
def test_backward_compatibility():
    """Verify new evaluator produces same results as hardcoded SQL."""
    ...
```

### Project Structure Notes

- Config file follows existing pattern in `config/` directory (e.g., `foreign_keys.yml`)
- StatusEvaluator follows service pattern in `customer_mdm/` module
- Pydantic config schema follows pattern in `infrastructure/settings/`

### References

- [Source: docs/business-background/customer-mdm-backfill-analysis.md#6-status-evaluation-framework-design]
- [Source: _bmad-output/planning-artifacts/sprint-change-proposal/sprint-change-proposal-2026-02-11-customer-mdm-optimization.md#story-7.6-18]
- [Source: docs/architecture/architectural-decisions.md#decision-12]
- [Source: src/work_data_hub/customer_mdm/snapshot_refresh.py] - Current hardcoded implementation

## Dev Agent Record

### Agent Model Used

Claude Opus 4.6

### Debug Log References

N/A - No debug issues encountered

### Completion Notes List

- Created config-driven status evaluation framework replacing hardcoded SQL
- StatusEvaluator generates SQL fragments from YAML configuration
- All 4 status types implemented: is_winning_this_year, is_loss_reported, is_churned_this_year, is_new
- Integrated with snapshot_refresh.py for both ProductLine and Plan granularity
- Added structured logging for audit trail
- 34 tests total (6 schema, 17 unit, 7 integration, 4 snapshot_refresh)

**Code Review Fixes (2026-02-15):**
- Fixed SQL injection vulnerability in `_generate_field_equals` using parameterized queries
- Implemented missing condition types: `disappeared` and `first_appearance`
- Added SQL identifier validation for all field names (防注入)
- Fixed `_generate_negation` silent failure - now raises explicit error
- Improved type hints from `Any` to `ConditionConfig`
- Added `reset_status_evaluator()` for test isolation
- Increased log truncation from 50 to 100 characters
- Centralized config path as `DEFAULT_CONFIG_PATH` constant

### File List

- config/customer_status_rules.yml (CREATE)
- src/work_data_hub/infrastructure/settings/customer_status_schema.py (CREATE)
- src/work_data_hub/customer_mdm/status_evaluator.py (CREATE)
- src/work_data_hub/customer_mdm/snapshot_refresh.py (MODIFY)
- tests/unit/customer_mdm/test_customer_status_schema.py (CREATE)
- tests/unit/customer_mdm/test_status_evaluator.py (CREATE)
- tests/unit/customer_mdm/test_snapshot_refresh.py (MODIFY)
- tests/integration/customer_mdm/test_status_evaluation.py (CREATE)
