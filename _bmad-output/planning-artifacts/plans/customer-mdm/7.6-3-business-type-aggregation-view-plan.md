# Implementation Plan: Story 7.6-3 Business Type Aggregation View

**Story:** 7.6-3-business-type-aggregation-view
**Status:** Ready for Implementation
**Created:** 2026-01-15

---

## 1. Overview

Create a pre-aggregated PostgreSQL view `v_customer_business_monthly_status_by_type` in the `customer` schema that groups customer award/loss data by business type (受托/投资) with monthly aggregation.

### Objective

Enable BI Analysts to quickly analyze award/loss patterns across different product lines without writing complex SQL joins.

---

## 2. Implementation Steps

### Step 1: Create Alembic Migration File

**File:** `io/schema/migrations/versions/006_create_business_type_view.py`

**Actions:**
1. Create migration file following the pattern from `005_create_annual_loss.py`
2. Set revision ID: `20260115_000006`
3. Set down_revision: `20260115_000005`
4. Implement `_view_exists()` helper function for idempotency

**Key Pattern to Follow:**
```python
revision = "20260115_000006"
down_revision = "20260115_000005"
```

---

### Step 2: Implement View SQL in upgrade()

**View Name:** `customer.v_customer_business_monthly_status_by_type`

**SQL Strategy:** Use CTE with UNION ALL to combine 当年中标 and 当年流失 tables, then aggregate with FILTER clauses.

**Columns to Include:**
| Column | Type | Description |
|--------|------|-------------|
| `上报月份` | DATE | Report month dimension |
| `业务类型` | VARCHAR | Business type (企年受托/企年投资) |
| `award_count` | INTEGER | Count of awards |
| `award_distinct_companies` | INTEGER | Distinct company_ids with awards (NULL excluded) |
| `loss_count` | INTEGER | Count of losses |
| `loss_distinct_companies` | INTEGER | Distinct company_ids with losses (NULL excluded) |
| `net_change` | INTEGER | award_count - loss_count |

**NULL Handling (AC-3):**
- `COUNT(*)` includes all records regardless of company_id
- `COUNT(DISTINCT company_id) FILTER (WHERE company_id IS NOT NULL)` excludes NULLs

---

### Step 3: Implement downgrade()

**Actions:**
1. Drop the view with `DROP VIEW IF EXISTS customer.v_customer_business_monthly_status_by_type`
2. Use CASCADE to handle any dependent objects

---

### Step 4: Run Migration and Verify

**Commands:**
```bash
# Run migration
uv run --env-file .wdh_env alembic upgrade head

# Verify view exists and returns data
# (via psql or DBeaver)
SELECT * FROM customer.v_customer_business_monthly_status_by_type LIMIT 10;
```

---

### Step 5: Update Documentation

**File:** `docs/database-schema-panorama.md`

**Actions:**
1. Update customer schema section (currently marked as empty)
2. Add view definition and column descriptions
3. Update schema summary table

---

## 3. Technical Details

### Source Tables

| Table | Schema | Key Columns |
|-------|--------|-------------|
| `当年中标` | customer | 上报月份, 业务类型, company_id |
| `当年流失` | customer | 上报月份, 业务类型, company_id |

### View SQL (Reference Implementation)

```sql
CREATE VIEW customer.v_customer_business_monthly_status_by_type AS
WITH combined AS (
    SELECT "上报月份", "业务类型", company_id, 'award' AS record_type
    FROM customer."当年中标"
    UNION ALL
    SELECT "上报月份", "业务类型", company_id, 'loss' AS record_type
    FROM customer."当年流失"
)
SELECT
    "上报月份",
    "业务类型",
    COUNT(*) FILTER (WHERE record_type = 'award') AS award_count,
    COUNT(DISTINCT company_id) FILTER (WHERE record_type = 'award' AND company_id IS NOT NULL) AS award_distinct_companies,
    COUNT(*) FILTER (WHERE record_type = 'loss') AS loss_count,
    COUNT(DISTINCT company_id) FILTER (WHERE record_type = 'loss' AND company_id IS NOT NULL) AS loss_distinct_companies,
    COUNT(*) FILTER (WHERE record_type = 'award') - COUNT(*) FILTER (WHERE record_type = 'loss') AS net_change
FROM combined
GROUP BY "上报月份", "业务类型"
ORDER BY "上报月份" DESC, "业务类型";
```

---

## 4. Acceptance Criteria Mapping

| AC | Description | Implementation |
|----|-------------|----------------|
| AC-1 | Create view in customer schema | Step 2 - CREATE VIEW statement |
| AC-2 | Provide key metrics per business type | Step 2 - SELECT columns with FILTER |
| AC-3 | Handle NULL company_id gracefully | Step 2 - FILTER with IS NOT NULL |
| AC-4 | Alembic migration as 006_* | Step 1 - Migration file creation |
| AC-5 | Query-able via standard SQL | Step 4 - Verification queries |

---

## 5. Dependencies

- **Prerequisite:** Migration 005 (当年流失 table) must be applied
- **No code dependencies:** View is pure SQL, no Python code required

---

## 6. Risks and Mitigations

| Risk | Mitigation |
|------|------------|
| Empty source tables | View will return empty result set (acceptable) |
| Migration chain break | Verify down_revision matches 005 revision ID |
| View performance | Simple aggregation, no complex joins - acceptable |

---

## 7. Verification Checklist

- [ ] Migration file created at correct path
- [ ] Revision chain is correct (005 → 006)
- [ ] View created successfully via `alembic upgrade head`
- [ ] View returns expected columns
- [ ] NULL company_ids excluded from distinct counts
- [ ] Documentation updated

---

**Plan Status:** Ready for Approval
