# Optimization Requirements

本文档记录 WorkDataHub 项目的优化需求，便于后续迭代实施。（目前均已实现）

---

## OPT-005: Pydantic Model 自动生成 DDL 方案

### 需求概述

实现从 Pydantic Domain Models 自动生成 SQLAlchemy DDL 的能力，消除 Pydantic 模型与 Alembic 迁移之间的手动同步需求，建立单一数据源 (Single Source of Truth)。

### 背景信息

**发现时间：** 2025-12-06 (Story 6.1 实现阶段)

**发现场景：**
在实现 Enterprise Schema 迁移时，发现 Domain 中的 Pydantic Models (`AnnuityPerformanceOut`) 与 Alembic 迁移文件中的表定义需要手动保持一致。当前架构存在以下问题：

1. **双重定义**：字段在 Pydantic model 和 Alembic migration 中各定义一次
2. **同步风险**：修改 model 后容易忘记更新迁移，或反之
3. **类型映射**：Python 类型到 SQL 类型的映射需要人工判断
4. **字段命名**：中文字段名 (Pydantic) 与英文列名 (DB) 的映射分散在多处

### 当前架构分析

```
┌─────────────────────────────────────────────────────────────────────┐
│                        当前状态 (双重定义)                           │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  Domain Models (Pydantic)              Alembic Migrations           │
│  ┌─────────────────────┐              ┌─────────────────────┐      │
│  │ AnnuityPerformanceOut│              │ 20251129_000001     │      │
│  │ - 计划代码: str(255) │   ← 手动同步 → │ plan_code VARCHAR   │      │
│  │ - company_id: str(50)│              │ company_id VARCHAR  │      │
│  │ - 月度: date         │              │ reporting_month DATE│      │
│  │ - ...               │              │ ...                 │      │
│  └─────────────────────┘              └─────────────────────┘      │
│                                                                     │
│  ⚠️ 问题: 两边定义独立，需要人工保持一致                              │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 目标架构

```
┌─────────────────────────────────────────────────────────────────────┐
│                        目标状态 (单一数据源)                         │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  Domain Models (Pydantic)              DDL Generator                │
│  ┌─────────────────────┐              ┌─────────────────────┐      │
│  │ AnnuityPerformanceOut│  ──自动──→  │ pydantic_to_ddl()   │      │
│  │ - 计划代码: str(255) │              │                     │      │
│  │   db_column="plan_code"             │ 生成 SQLAlchemy     │      │
│  │ - company_id: str(50)│              │ Column 定义         │      │
│  │ - 月度: date         │              │                     │      │
│  └─────────────────────┘              └─────────────────────┘      │
│           │                                    │                    │
│           │                                    ↓                    │
│           │                           ┌─────────────────────┐      │
│           │                           │ Alembic Migration   │      │
│           │                           │ (自动生成)          │      │
│           │                           └─────────────────────┘      │
│           │                                    │                    │
│           ↓                                    ↓                    │
│  ┌─────────────────────┐              ┌─────────────────────┐      │
│  │ API / Validation    │              │ Database Tables     │      │
│  └─────────────────────┘              └─────────────────────┘      │
│                                                                     │
│  ✅ 单一数据源: Pydantic Model 是唯一的 Schema 定义                  │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 功能需求

#### 核心需求

1. **扩展 Pydantic Field 元数据**
   - 添加 `db_column` 参数指定数据库列名
   - 添加 `db_type` 参数覆盖默认类型映射
   - 添加 `db_constraint` 参数指定约束

2. **类型映射引擎**
   - Python `str` → SQL `VARCHAR(max_length)`
   - Python `date` → SQL `DATE`
   - Python `Decimal` → SQL `NUMERIC(precision, scale)`
   - Python `int` → SQL `INTEGER`
   - Python `Optional[X]` → `nullable=True`

3. **DDL 生成器**
   - 从 Pydantic model 生成 `sa.Column` 列表
   - 支持主键、唯一约束、CHECK 约束
   - 支持索引定义

4. **迁移集成**
   - 在 Alembic 迁移中调用生成器
   - 支持增量迁移（字段变更检测）

### 建议实现方案

#### 1. 扩展 Field 定义

```python
# src/work_data_hub/domain/annuity_performance/models.py
from pydantic import Field
from work_data_hub.io.schema.field_meta import DBColumn

class AnnuityPerformanceOut(BaseModel):
    月度: date = Field(
        ...,
        description="Report date",
        json_schema_extra=DBColumn(
            name="reporting_month",
            primary_key=True,
        ).dict()
    )
    计划代码: str = Field(
        ...,
        max_length=255,
        json_schema_extra=DBColumn(
            name="plan_code",
            primary_key=True,
        ).dict()
    )
    期初资产规模: Optional[Decimal] = Field(
        None,
        decimal_places=4,
        json_schema_extra=DBColumn(
            name="starting_assets",
            sql_type="NUMERIC(18, 4)",
            check="starting_assets >= 0",
        ).dict()
    )
```

#### 2. DBColumn 元数据类

```python
# src/work_data_hub/io/schema/field_meta.py
from dataclasses import dataclass
from typing import Optional

@dataclass
class DBColumn:
    """Database column metadata for Pydantic fields."""
    name: str                          # DB column name
    sql_type: Optional[str] = None     # Override auto-detected type
    primary_key: bool = False
    unique: bool = False
    index: bool = False
    check: Optional[str] = None        # CHECK constraint expression
    comment: Optional[str] = None      # Column comment

    def dict(self) -> dict:
        return {k: v for k, v in self.__dict__.items() if v is not None}
```

#### 3. DDL 生成器

```python
# src/work_data_hub/io/schema/ddl_generator.py
from typing import Type, List
from pydantic import BaseModel
import sqlalchemy as sa

TYPE_MAP = {
    str: lambda f: sa.String(f.metadata.get("max_length", 255)),
    int: lambda f: sa.Integer(),
    float: lambda f: sa.Float(),
    date: lambda f: sa.Date(),
    Decimal: lambda f: sa.Numeric(
        precision=18,
        scale=f.metadata.get("decimal_places", 4)
    ),
}

def pydantic_to_columns(model: Type[BaseModel]) -> List[sa.Column]:
    """Generate SQLAlchemy columns from Pydantic model."""
    columns = []

    for field_name, field_info in model.model_fields.items():
        # Get DB metadata
        db_meta = field_info.json_schema_extra or {}
        if not isinstance(db_meta, dict):
            continue

        col_name = db_meta.get("name", field_name)

        # Determine SQL type
        if sql_type_str := db_meta.get("sql_type"):
            col_type = sa.text(sql_type_str)  # Raw SQL type
        else:
            base_type = _get_base_type(field_info.annotation)
            type_factory = TYPE_MAP.get(base_type, lambda f: sa.String(255))
            col_type = type_factory(field_info)

        # Build column
        col = sa.Column(
            col_name,
            col_type,
            primary_key=db_meta.get("primary_key", False),
            nullable=not field_info.is_required(),
            unique=db_meta.get("unique", False),
            index=db_meta.get("index", False),
            comment=db_meta.get("comment") or field_info.description,
        )
        columns.append(col)

    return columns


def generate_table(
    model: Type[BaseModel],
    table_name: str,
    schema: Optional[str] = None,
) -> sa.Table:
    """Generate SQLAlchemy Table from Pydantic model."""
    columns = pydantic_to_columns(model)
    return sa.Table(table_name, sa.MetaData(), *columns, schema=schema)
```

#### 4. 迁移中使用

```python
# io/schema/migrations/versions/xxx_create_annuity_performance.py
from work_data_hub.domain.annuity_performance.models import AnnuityPerformanceOut
from work_data_hub.io.schema.ddl_generator import pydantic_to_columns

def upgrade():
    columns = pydantic_to_columns(AnnuityPerformanceOut)
    op.create_table(
        "annuity_performance",
        *columns,
        # Additional audit columns not in model
        sa.Column("pipeline_run_id", sa.String(50)),
        sa.Column("created_at", sa.DateTime(timezone=True), server_default=func.now()),
        sa.Column("updated_at", sa.DateTime(timezone=True), onupdate=func.now()),
    )
```

### 短期替代方案（已实现）

在实现完整的 DDL 生成器之前，已实现 **Schema 一致性检查测试** 作为过渡方案：

**文件位置：** `tests/integration/test_schema_consistency.py`

**功能：**
- 验证 Pydantic model 字段与 DB 列名的映射关系
- 检测类型兼容性
- 检测必填字段与 NOT NULL 约束的一致性
- CI 中自动运行，及早发现不一致

### 影响范围

**需要新增的文件：**
- `src/work_data_hub/io/schema/field_meta.py` - DBColumn 元数据类
- `src/work_data_hub/io/schema/ddl_generator.py` - DDL 生成器
- `tests/unit/io/schema/test_ddl_generator.py` - 单元测试

**需要修改的文件：**
- `src/work_data_hub/domain/annuity_performance/models.py` - 添加 DB 元数据
- `src/work_data_hub/domain/annuity_income/models.py` - 添加 DB 元数据
- 未来的 Alembic 迁移文件

### 优先级与排期

- **优先级：** Low (长期优化)
- **建议排期：** Epic 7+ 或技术债务清理阶段
- **预估工作量：** 8-12 小时
- **前置条件：** 方案 C (一致性检查测试) 已实现并稳定运行

### 验收标准

1. 从 Pydantic model 生成的 DDL 与手写迁移等效
2. 支持所有常用 Python 类型到 SQL 类型的映射
3. 支持主键、唯一约束、CHECK 约束、索引
4. 单元测试覆盖率 > 90%
5. 现有迁移可逐步迁移到新方案
6. 文档说明使用方法和最佳实践

### 风险与缓解

| 风险 | 影响 | 缓解措施 |
|------|------|----------|
| 类型映射不完整 | 生成错误的 SQL 类型 | 提供 `sql_type` 覆盖机制 |
| 复杂约束难以表达 | 无法生成某些约束 | 支持原始 SQL 约束字符串 |
| 迁移兼容性 | 与现有迁移冲突 | 渐进式迁移，新表优先使用 |
| 学习成本 | 团队需要学习新模式 | 提供详细文档和示例 |

### 替代方案对比

| 方案 | 优点 | 缺点 | 推荐度 |
|------|------|------|--------|
| A: Pydantic → DDL | 单一数据源，自动同步 | 需要开发，类型映射复杂 | ⭐⭐⭐ |
| B: SQLAlchemy ORM | Alembic 原生支持 autogenerate | 需维护两套模型 | ⭐⭐ |
| C: 一致性检查 | 最小改动，CI 自动检测 | 仍需手动同步 | ⭐⭐⭐⭐ (短期) |

**建议路径：** 短期采用方案 C，中长期评估方案 A 的 ROI 后决定是否实施。

---

## OPT-006: (预留)

---

**文档版本：** 1.3
**创建日期：** 2025-12-06
**最后更新：** 2025-12-06
