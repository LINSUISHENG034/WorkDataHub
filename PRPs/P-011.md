name: "C-017: Relax Input Types for Trustee Performance Metrics (Excel Numeric Cells)"
description: |

## Purpose
Fix runtime ValidationErrors when processing real Excel data by allowing numeric Excel cell values (int/float/Decimal) for trustee_performance input metrics while preserving strict output validation and existing behavior.

## Core Principles
1. **Context is King**: Include ALL necessary documentation, examples, and caveats
2. **Validation Loops**: Provide executable tests/lints the AI can run and fix
3. **Information Dense**: Use keywords and patterns from the codebase
4. **Progressive Success**: Start simple, validate, then enhance
5. **Global rules**: Be sure to follow all rules in CLAUDE.md

---

## Goal
Update `TrusteePerformanceIn` model to accept Union[Decimal, float, int, str] types for the three metric fields (收益率, 净值, 规模) while keeping `TrusteePerformanceOut` unchanged. This eliminates Pydantic ValidationErrors when Excel provides numeric cell values instead of strings, allowing the ETL pipeline to process real Excel files successfully.

## Why
- **Business value**: Prevents ETL job failures caused by Excel's native numeric cell types
- **Integration**: Maintains existing transformation logic and output validation
- **Problems solved**: Eliminates high error rates that cause `TrusteePerformanceTransformationError`

## What
Modify input model field definitions to accept flexible numeric/string types while preserving all existing validation behavior in the output model and transformation service.

### Success Criteria
- [ ] Excel numeric cells (float/int) are accepted without ValidationError
- [ ] String inputs continue to work as before (backward compatible)
- [ ] Output model validation remains unchanged and strict
- [ ] All existing tests pass
- [ ] New tests validate numeric input scenarios
- [ ] E2E processing succeeds on sample Excel files

## All Needed Context

### Documentation & References
```yaml
# MUST READ - Include these in your context window
- url: https://docs.pydantic.dev/latest/concepts/unions/
  why: Pydantic v2 Union types with 'smart' mode for automatic type coercion
  
- url: https://docs.pydantic.dev/latest/api/types/#pydantic.types.Union
  why: Union type validation behavior and ordering rules
  
- file: src/work_data_hub/domain/trustee_performance/models.py
  why: Current model definitions, existing validators, field patterns to modify
  
- file: tests/domain/trustee_performance/test_service.py
  why: Existing test patterns, fixture structure, assertion styles to follow
  
- file: VALIDATION.md
  why: Shows exact error patterns that need to be fixed
  
- docfile: CLAUDE.md
  why: Python typing conventions, Union vs | syntax, import standards
```

### Current Codebase Tree (relevant sections)
```bash
src/work_data_hub/
├── domain/
│   └── trustee_performance/
│       ├── models.py              # TrusteePerformanceIn/Out models
│       └── service.py             # _transform_single_row logic
tests/domain/trustee_performance/
├── test_service.py                # Existing test patterns
└── test_service_bug.py
```

### Desired Codebase Tree (files to modify)
```bash
src/work_data_hub/domain/trustee_performance/
├── models.py                      # MODIFY: Update field types to Union types
└── service.py                     # UNCHANGED: Transformation logic works with Union
tests/domain/trustee_performance/
└── test_service.py                # ADD: New test cases for numeric inputs
```

### Known Gotchas & Library Quirks
```python
# CRITICAL: Pydantic v2 uses 'smart' mode by default for Union types
# This means Union[Decimal, float, int, str] will automatically coerce numeric strings
# Order matters only if using union_mode='left_to_right'

# CRITICAL: Existing clean_decimal_fields validator already handles multiple input types
# The validator returns values unchanged if they're already numeric types
# Pydantic will then coerce them appropriately for the output model

# CRITICAL: Use typing.Union for Python 3.10 compatibility (not | operator)
from typing import Union  # Required import

# CRITICAL: Keep existing field descriptions and Field() definitions identical
# Only change the type annotation, not the Field parameters

# CRITICAL: Optional[Union[...]] means the field can be None OR any of the Union types
from typing import Optional, Union
```

### Current Implementation Analysis
```python
# CURRENT: TrusteePerformanceIn fields (PROBLEMATIC)
收益率: Optional[str] = Field(None, description="Return rate (收益率)")
净值: Optional[str] = Field(None, description="Net asset value (净值)")  
规模: Optional[str] = Field(None, description="Scale/size (规模)")

# EXISTING: TrusteePerformanceOut fields (KEEP UNCHANGED)
return_rate: Optional[Decimal] = Field(None, decimal_places=6, ge=-1.0, le=10.0)
net_asset_value: Optional[Decimal] = Field(None, decimal_places=4, gt=0)
fund_scale: Optional[Decimal] = Field(None, decimal_places=2, ge=0)

# EXISTING: clean_decimal_fields validator already handles Union types
@field_validator("return_rate", "net_asset_value", "fund_scale", mode="before")
@classmethod
def clean_decimal_fields(cls, v):
    if isinstance(v, (int, float, Decimal)):
        return v  # Already numeric - return unchanged
```

## Implementation Blueprint

### Data Models and Structure

The core issue is type mismatch between Excel's native numeric cells and Pydantic's string expectations.

```python
# BEFORE: String-only fields cause ValidationError
class TrusteePerformanceIn(BaseModel):
    收益率: Optional[str] = Field(None, description="Return rate (收益率)")
    
# AFTER: Union types accept both numeric and string inputs
class TrusteePerformanceIn(BaseModel):  
    收益率: Optional[Union[Decimal, float, int, str]] = Field(None, description="Return rate (收益率)")
```

### List of Tasks to Complete

```yaml
Task 1: Update Import Statements
MODIFY src/work_data_hub/domain/trustee_performance/models.py:
  - FIND pattern: "from typing import" line
  - ENSURE imports: Union (add if missing)
  - ENSURE imports: Decimal (add if missing) 
  - PRESERVE: All existing imports

Task 2: Update Metric Field Types  
MODIFY src/work_data_hub/domain/trustee_performance/models.py:
  - FIND pattern: '收益率: Optional[str] = Field(None, description="Return rate (收益率)")'
  - REPLACE with: '收益率: Optional[Union[Decimal, float, int, str]] = Field(None, description="Return rate (收益率)")'
  - FIND pattern: '净值: Optional[str] = Field(None, description="Net asset value (净值)")'  
  - REPLACE with: '净值: Optional[Union[Decimal, float, int, str]] = Field(None, description="Net asset value (净值)")'
  - FIND pattern: '规模: Optional[str] = Field(None, description="Scale/size (规模)")'
  - REPLACE with: '规模: Optional[Union[Decimal, float, int, str]] = Field(None, description="Scale/size (规模)")'
  - PRESERVE: All other field definitions unchanged
  - PRESERVE: All validators unchanged

Task 3: Add Comprehensive Test Cases
MODIFY tests/domain/trustee_performance/test_service.py:
  - PATTERN: Follow existing fixture style from valid_row_chinese
  - ADD test: test_numeric_cells_are_accepted_and_converted()
  - ADD test: test_mixed_numeric_string_inputs() 
  - PRESERVE: All existing test functions unchanged
  - MIRROR: Assertion patterns from existing tests
```

### Per Task Pseudocode

```python
# Task 2: Update field definitions
# PATTERN: Keep everything identical except type annotation
# BEFORE
收益率: Optional[str] = Field(None, description="Return rate (收益率)")

# AFTER  
收益率: Optional[Union[Decimal, float, int, str]] = Field(None, description="Return rate (收益率)")

# Task 3: Add test cases that match VALIDATION.md error patterns
def test_numeric_cells_are_accepted_and_converted():
    """Test exact error scenario from VALIDATION.md"""
    row = {
        "年": "2024",
        "月": "11", 
        "计划代码": "PLAN001",
        "公司代码": "COMP001",
        "净值": 1.0512,        # float from Excel (was causing error)
        "规模": 12000000,       # int from Excel (was causing error)  
        "收益率": 0.055,         # float decimal form
    }
    
    # CRITICAL: This should NOT raise ValidationError anymore
    result = _transform_single_row(row, "test", 0)
    
    # PATTERN: Follow existing assertion style
    assert result is not None
    assert isinstance(result, TrusteePerformanceOut)
    assert result.net_asset_value == Decimal("1.0512")
    assert result.fund_scale == Decimal("12000000") 
    assert result.return_rate == Decimal("0.055")
```

### Integration Points
```yaml
UNCHANGED COMPONENTS:
  - TrusteePerformanceOut model: Keep all validations strict
  - Service transformation: _transform_single_row logic unchanged
  - Clean validators: Existing clean_decimal_fields handles Union types
  - Excel reader: Continues returning native Python types
  
VALIDATION FLOW:
  - Excel reader: Returns float(1.0512), int(12000000) 
  - TrusteePerformanceIn: Now accepts these types (no ValidationError)
  - Service transformation: Passes values to output model unchanged
  - TrusteePerformanceOut: clean_decimal_fields converts to Decimal
```

## Validation Loop

### Level 1: Syntax & Style
```bash
# Run these FIRST - fix any errors before proceeding
uv run ruff check src/work_data_hub/domain/trustee_performance/models.py --fix
uv run mypy src/work_data_hub/domain/trustee_performance/

# Expected: No errors. If Union import missing, add it.
# Expected: No type errors. Union[Decimal, float, int, str] is valid.
```

### Level 2: Unit Tests
```python
# ADD TO tests/domain/trustee_performance/test_service.py
def test_numeric_cells_are_accepted_and_converted():
    """Test that numeric Excel cells work without ValidationError."""
    row = {
        "年": "2024",
        "月": "11",
        "计划代码": "PLAN001", 
        "公司代码": "COMP001",
        "净值": 1.0512,       # Excel float
        "规模": 12000000,      # Excel int
        "收益率": 0.055,        # Excel decimal
    }
    # Should not raise ValidationError
    result = _transform_single_row(row, "test", 0)
    assert result is not None
    assert result.net_asset_value == Decimal("1.0512")

def test_mixed_numeric_string_inputs():  
    """Test mixing numeric and string inputs (backward compatibility)."""
    row = {
        "年": "2024",
        "月": "11",
        "计划代码": "PLAN001",
        "公司代码": "COMP001", 
        "净值": "1.0512",      # String (existing behavior)
        "规模": 12000000,       # Numeric (new capability)
        "收益率": "5.5%",        # String percentage (existing behavior)
    }
    result = _transform_single_row(row, "test", 0)
    assert result is not None
    assert result.net_asset_value == Decimal("1.0512")
    assert result.fund_scale == Decimal("12000000")
    assert result.return_rate == Decimal("0.055")  # 5.5% -> 0.055
```

```bash
# Run tests iteratively until passing:
uv run pytest tests/domain/trustee_performance/ -v
# If failing: Read error, fix code, re-run (never skip failures)

# Run broader test suite to ensure no regressions
uv run pytest -v -k "trustee_performance and not postgres"  
```

### Level 3: Integration Test
```bash
# Test actual Excel processing that was failing
uv run python -m src.work_data_hub.orchestration.jobs --execute --max-files 2

# Expected: No more "Input should be a valid string" errors
# Expected: Processing completes successfully without TrusteePerformanceTransformationError
# Expected: Data loads into warehouse with proper Decimal types
```

## Final Validation Checklist
- [ ] All tests pass: `uv run pytest tests/domain/trustee_performance/ -v`
- [ ] No linting errors: `uv run ruff check src/`
- [ ] No type errors: `uv run mypy src/`
- [ ] Broader test suite passes: `uv run pytest -v -k "trustee_performance and not postgres"`
- [ ] E2E processing succeeds: `uv run python -m src.work_data_hub.orchestration.jobs --execute --max-files 2`
- [ ] VALIDATION.md error patterns eliminated
- [ ] Backward compatibility: String inputs still work
- [ ] Output types remain strictly validated Decimals

---

## Anti-Patterns to Avoid
- ❌ Don't change TrusteePerformanceOut field types - keep output strict
- ❌ Don't modify existing validators - they already handle Union types correctly
- ❌ Don't use | operator for Union (Python 3.10 compatibility)
- ❌ Don't change Field() parameters, only type annotations
- ❌ Don't skip running the E2E test - it verifies the actual fix
- ❌ Don't add new validation logic - leverage Pydantic's built-in Union handling

## Confidence Score: 9/10

High confidence due to:
- Simple, focused change (only field type annotations)
- Existing validator already handles multiple input types correctly
- Clear error patterns from VALIDATION.md to verify fix
- Comprehensive test patterns to follow from existing codebase
- No breaking changes - Union includes str for backward compatibility
- Well-understood Pydantic v2 Union type behavior

Minor uncertainty only around ensuring all edge cases in existing tests continue to pass, but the change is strictly additive (Union includes the original str type).