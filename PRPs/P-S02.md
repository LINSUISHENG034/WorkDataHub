name: "EQC Authentication Automation with Playwright"
description: |

## Purpose
Automate EQC platform authentication token acquisition through browser automation, replacing manual developer tools token extraction with an interactive, user-friendly authentication flow using Playwright.

## Core Principles
1. **Context is King**: Include ALL necessary documentation, examples, and caveats
2. **Validation Loops**: Provide executable tests/lints the AI can run and fix
3. **Information Dense**: Use keywords and patterns from the codebase
4. **Progressive Success**: Start simple, validate, then enhance
5. **Global rules**: Be sure to follow all rules in CLAUDE.md

---

## Goal
Replace the manual EQC token extraction process (opening browser dev tools, finding network requests, copying token headers) with an automated interactive authentication system that launches a browser, allows user login, automatically captures the authentication token, and seamlessly integrates with the existing EqcCrawler workflow.

## Why
- **Business value**: Eliminates complex manual token extraction process, making EQC data collection accessible to non-technical users
- **Integration**: Maintains compatibility with existing EqcCrawler while modernizing the authentication flow
- **Problems solved**: Token expiration management, user experience complexity, and authentication workflow automation for corporate data enrichment pipelines

## What
An interactive authentication module that:
- Launches a headed browser window automatically
- Navigates to EQC login page (https://eqc.pingan.com/)
- Allows user to complete login manually (handles 2FA, captchas, etc.)
- Intercepts network requests to capture authentication tokens
- Returns captured token to caller for immediate use
- Handles timeouts and error conditions gracefully
- Integrates seamlessly with existing EqcCrawler initialization

### Success Criteria
- [ ] Browser launches automatically in headed mode
- [ ] Network request interception successfully captures token from `/kg-api-hfd/api/search/` requests
- [ ] Token validation confirms successful authentication
- [ ] EqcCrawler integration works without breaking existing functionality
- [ ] Timeout handling prevents indefinite waiting
- [ ] Error conditions (browser closed early, network issues) handled gracefully
- [ ] All tests pass and code meets quality standards

## All Needed Context

### Documentation & References
```yaml
# MUST READ - Include these in your context window
- url: https://playwright.dev/python/docs/api/class-browsercontext#browser-context-route
  why: Network request interception patterns for token extraction

- url: https://playwright.dev/python/docs/api/class-route#route-continue
  why: Proper async route handling and continuation patterns

- url: https://playwright.dev/python/docs/network#handle-responses
  why: Response and request header manipulation techniques

- file: legacy/annuity_hub/crawler/eqc_crawler.py
  why: Existing token usage pattern, HTTP headers structure, API endpoints

- file: tools/eqc_token_manager.py
  why: Current token management approach and validation methods

- file: src/work_data_hub/config/settings.py
  why: Project configuration patterns and environment variable handling

- file: legacy/annuity_hub/crawler/run.py
  why: Current EqcCrawler initialization and usage patterns

- url: https://playwright.dev/python/docs/browsers#launching-a-browser
  why: Browser lifecycle management in headed mode with user interaction
```

### Implementation-Facing Research Notes
```yaml
sources:
  - url: https://playwright.dev/python/docs/api/class-browsercontext#browser-context-route
    section: network-interception
    why: Token extraction from network requests
    type: docs

  - url: https://playwright.dev/python/docs/network#handle-responses
    section: request-headers
    why: HTTP header manipulation and extraction patterns
    type: docs

tldr:
  - Playwright supports async network request interception via page.route()
  - Route handlers must call await route.continue_() to proceed with requests
  - Headers can be extracted from route.request.headers dictionary
  - Browser instances should be properly closed to prevent resource leaks
  - Headed mode allows real user interaction for login completion

setup_commands:
  - "uv add playwright"
  - "uv run playwright install"
  - "# Browser binaries will be downloaded automatically"

api_decisions:
  - name: async_playwright
    choice: async context manager pattern
    rationale: Ensures proper browser cleanup and matches project async patterns

  - name: browser_launch
    choice: chromium.launch(headless=False)
    rationale: Headed mode required for user interaction, Chromium most stable

  - name: route_pattern
    choice: "**/*" with URL filtering
    rationale: Intercept all requests, filter by URL pattern for efficiency

versions:
  - library: playwright
    constraint: ">=1.40.0"
    compatibility: python 3.10+, async/await support required

pitfalls_and_mitigations:
  - issue: Browser processes may not close properly
    mitigation: Use async context managers and explicit browser.close()

  - issue: Network interception can slow page loads
    mitigation: Only intercept necessary request patterns, immediately continue non-target requests

  - issue: Token may change format or header name
    mitigation: Make token extraction configurable via constants at module top

open_questions:
  - Should we cache tokens temporarily for session reuse?
  - How to handle multiple concurrent authentication requests?
```

### Current Codebase tree
```bash
src/work_data_hub/
  config/
    settings.py            # pydantic‑settings; env vars prefixed WDH_*
    schema.py              # config schema validation
    data_sources.yml       # discovery patterns, selection, table/pk
  io/
    connectors/
      file_connector.py    # config‑driven file discovery
    readers/
      excel_reader.py      # resilient Excel ingestion
    loader/
      warehouse_loader.py  # PostgreSQL loader (plan‑only or execute)
  domain/
    company_enrichment/
      models.py            # Company mapping and resolution models
      service.py           # Company enrichment business logic
  orchestration/
    ops.py                 # discover/read/process/load ops
    jobs.py                # single/multi‑file jobs + CLI entry
    repository.py          # Dagster Definitions registry
  utils/
    types.py               # shared types/helpers

legacy/annuity_hub/
  crawler/
    eqc_crawler.py         # Existing EQC integration (token-based)
    run.py                 # Current crawler usage patterns
tools/
  eqc_token_manager.py     # Manual token storage and validation
```

### Desired Codebase tree with files to be added and responsibility of file
```bash
src/work_data_hub/
  auth/                    # NEW: Authentication module
    __init__.py            # Package init
    eqc_auth_handler.py    # Interactive token acquisition via Playwright
    models.py              # Authentication-related Pydantic models
  domain/
    company_enrichment/    # UPDATED: Integration with new auth
      service.py           # Enhanced to use automated token acquisition
```

### Known Gotchas of our codebase & Library Quirks
```python
# CRITICAL: EqcCrawler expects token in specific header format
# From legacy/annuity_hub/crawler/eqc_crawler.py:54-57
headers = dict(self.headers, **{
    'Referer': 'https://eqc.pingan.com/',
    'token': self.token  # Token goes in 'token' header, not 'Authorization'
})

# CRITICAL: Target API endpoint pattern for token capture
# From legacy/annuity_hub/crawler/eqc_crawler.py:53
TARGET_API_PATH = "/kg-api-hfd/api/search/"
LOGIN_URL = "https://eqc.pingan.com/"

# CRITICAL: Project uses WDH_ prefix for environment variables
# From src/work_data_hub/config/settings.py pattern
WDH_AUTH_TIMEOUT_SECONDS = 300  # 5 minute default timeout

# CRITICAL: Async/await patterns must match Dagster expectations
# Project uses async context managers and proper cleanup patterns
```

## Implementation Blueprint

### Data models and structure

Create core authentication models for type safety and validation.
```python
# src/work_data_hub/auth/models.py
from datetime import datetime
from typing import Optional
from pydantic import BaseModel, Field, validator

class AuthTokenResult(BaseModel):
    """Result of authentication token acquisition."""
    token: str = Field(..., min_length=20, max_length=100)
    captured_at: datetime = Field(default_factory=datetime.now)
    source_url: str
    validated: bool = False

    @validator('token')
    def validate_token_format(cls, v):
        # Basic token format validation
        if not v or len(v.strip()) < 20:
            raise ValueError('Token must be at least 20 characters')
        return v.strip()

class AuthenticationError(Exception):
    """Custom exception for authentication failures."""
    pass

class AuthTimeoutError(AuthenticationError):
    """Raised when authentication times out."""
    pass
```

### List of tasks to be completed to fulfill the PRP in the order they should be completed

```yaml
Task 1:
CREATE src/work_data_hub/auth/__init__.py:
  - EMPTY package init file

CREATE src/work_data_hub/auth/models.py:
  - IMPLEMENT AuthTokenResult pydantic model
  - IMPLEMENT custom exception classes
  - VALIDATE token format and requirements

Task 2:
CREATE src/work_data_hub/auth/eqc_auth_handler.py:
  - IMPLEMENT get_auth_token_interactively() async function
  - CONFIGURE Playwright browser launch (headed mode)
  - IMPLEMENT network request interception for token capture
  - HANDLE timeouts and error conditions
  - INTEGRATE with existing logging patterns

Task 3:
MODIFY pyproject.toml:
  - ADD playwright dependency using uv add playwright
  - ENSURE version compatibility with existing dependencies

Task 4:
CREATE tests/auth/test_eqc_auth_handler.py:
  - IMPLEMENT unit tests for authentication models
  - MOCK Playwright interactions for testing
  - VALIDATE error handling and timeout scenarios

Task 5:
MODIFY legacy/annuity_hub/crawler/run.py:
  - IMPORT new authentication handler
  - REPLACE manual token input with automated acquisition
  - MAINTAIN backward compatibility for existing usage patterns

Task 6:
UPDATE documentation:
  - ADD usage examples to auth module docstrings
  - UPDATE README with new authentication flow
  - DOCUMENT environment variables and configuration options
```

### Per task pseudocode as needed added to each task

```python
# Task 2: Core authentication handler implementation
# src/work_data_hub/auth/eqc_auth_handler.py

import asyncio
import logging
from typing import Optional
from playwright.async_api import async_playwright, TimeoutError as PlaywrightTimeoutError

# CONSTANTS: Make these configurable for easy maintenance
LOGIN_URL = "https://eqc.pingan.com/"
TARGET_API_PATH = "/kg-api-hfd/api/search/"
DEFAULT_TIMEOUT_SECONDS = 300  # 5 minutes

logger = logging.getLogger(__name__)

async def get_auth_token_interactively(timeout_seconds: int = DEFAULT_TIMEOUT_SECONDS) -> Optional[str]:
    """
    Launch browser, allow user login, capture authentication token.

    PATTERN: Use async context manager for resource cleanup
    GOTCHA: Must call route.continue_() for all intercepted requests
    CRITICAL: Token comes from 'token' header, not 'Authorization'
    """
    logger.info("Starting interactive EQC authentication...")

    async with async_playwright() as playwright:
        # PATTERN: Launch headed browser for user interaction
        browser = await playwright.chromium.launch(headless=False)
        try:
            context = await browser.new_context()
            page = await context.new_page()

            # PATTERN: Use Future for cross-coroutine communication
            token_future = asyncio.Future()

            async def intercept_request(route):
                """Intercept and check requests for authentication token."""
                request = route.request
                # CRITICAL: Check for specific API endpoint
                if TARGET_API_PATH in request.url:
                    # CRITICAL: Token is in 'token' header, not Authorization
                    token = request.headers.get("token")
                    if token and not token_future.done():
                        logger.info("Successfully captured authentication token")
                        token_future.set_result(token)
                # GOTCHA: Must continue all requests or page will hang
                await route.continue_()

            # PATTERN: Intercept all network requests
            await context.route("**/*", intercept_request)

            # Navigate to login page
            await page.goto(LOGIN_URL, wait_until="domcontentloaded")
            logger.info("Browser opened - please complete login manually")

            try:
                # CRITICAL: Wait for token with timeout
                token = await asyncio.wait_for(token_future, timeout=timeout_seconds)
                return token
            except asyncio.TimeoutError:
                logger.error(f"Authentication timed out after {timeout_seconds} seconds")
                return None

        except Exception as e:
            logger.error(f"Authentication error: {e}")
            return None
        finally:
            # PATTERN: Always cleanup browser resources
            await browser.close()

# Helper function for sync compatibility
def run_get_token(timeout_seconds: int = DEFAULT_TIMEOUT_SECONDS) -> Optional[str]:
    """Synchronous wrapper for async authentication."""
    return asyncio.run(get_auth_token_interactively(timeout_seconds))
```

### Integration Points
```yaml
CONFIG:
  - add to: src/work_data_hub/config/settings.py
  - pattern: "auth_timeout_seconds: int = Field(default=300, ge=30, le=1800)"

DEPENDENCIES:
  - add to: pyproject.toml dependencies list
  - command: "uv add playwright"
  - post_install: "uv run playwright install"

LEGACY_INTEGRATION:
  - modify: legacy/annuity_hub/crawler/run.py
  - pattern: Replace manual token input with automated acquisition
  - maintain: Backward compatibility with existing DataCrawler usage

LOGGING:
  - follows: existing logging patterns from legacy/annuity_hub/logger/
  - level: INFO for user guidance, DEBUG for technical details
  - format: Consistent with project logging standards
```

## Validation Loop

### Level 1: Syntax & Style
```bash
# Run these FIRST - fix any errors before proceeding
uv add playwright                                    # Add dependency
uv run playwright install                           # Install browser binaries
ruff check src/work_data_hub/auth/ --fix           # Auto-fix style issues
mypy src/work_data_hub/auth/                        # Type checking

# Expected: No errors. If errors, READ the error and fix.
```

### Level 2: Unit Tests each new feature/file/function use existing test patterns
```python
# CREATE tests/auth/test_eqc_auth_handler.py with these test cases:
import pytest
from unittest.mock import AsyncMock, MagicMock, patch
from src.work_data_hub.auth.eqc_auth_handler import get_auth_token_interactively
from src.work_data_hub.auth.models import AuthTokenResult

def test_auth_token_result_validation():
    """Test token result model validation"""
    # Valid token
    result = AuthTokenResult(token="valid_token_12345678901234567890", source_url="https://example.com")
    assert result.token == "valid_token_12345678901234567890"

    # Invalid token - too short
    with pytest.raises(ValueError, match="Token must be at least 20 characters"):
        AuthTokenResult(token="short", source_url="https://example.com")

@pytest.mark.asyncio
async def test_successful_token_capture():
    """Test successful token capture via network interception"""
    with patch('src.work_data_hub.auth.eqc_auth_handler.async_playwright') as mock_playwright:
        # Mock the Playwright interaction
        mock_browser = AsyncMock()
        mock_context = AsyncMock()
        mock_page = AsyncMock()

        mock_playwright.return_value.__aenter__.return_value.chromium.launch.return_value = mock_browser
        mock_browser.new_context.return_value = mock_context
        mock_context.new_page.return_value = mock_page

        # Simulate token capture by immediately resolving
        async def mock_route_handler(route_pattern, handler):
            # Simulate calling the handler with a mock route containing our token
            mock_route = MagicMock()
            mock_request = MagicMock()
            mock_request.url = "https://eqc.pingan.com/kg-api-hfd/api/search/?key=test"
            mock_request.headers = {"token": "captured_test_token_1234567890"}
            mock_route.request = mock_request
            mock_route.continue_ = AsyncMock()
            await handler(mock_route)

        mock_context.route = mock_route_handler

        result = await get_auth_token_interactively(timeout_seconds=1)
        assert result == "captured_test_token_1234567890"

@pytest.mark.asyncio
async def test_authentication_timeout():
    """Test timeout handling when user doesn't complete login"""
    with patch('src.work_data_hub.auth.eqc_auth_handler.async_playwright') as mock_playwright:
        # Mock browser that never captures token
        mock_browser = AsyncMock()
        mock_context = AsyncMock()
        mock_page = AsyncMock()

        mock_playwright.return_value.__aenter__.return_value.chromium.launch.return_value = mock_browser
        mock_browser.new_context.return_value = mock_context
        mock_context.new_page.return_value = mock_page
        mock_context.route = AsyncMock()  # No token will be captured

        result = await get_auth_token_interactively(timeout_seconds=0.1)  # Very short timeout
        assert result is None
```

```bash
# Run and iterate until passing:
uv run pytest tests/auth/ -v
# If failing: Read error, understand root cause, fix code, re-run
```

### Level 3: Integration Test
```bash
# Manual integration test (requires human interaction)
# Create integration test script
cat > test_auth_integration.py << 'EOF'
#!/usr/bin/env python3
import asyncio
from src.work_data_hub.auth.eqc_auth_handler import get_auth_token_interactively

async def main():
    print("Starting authentication test...")
    print("Browser will open - please log in to EQC platform")

    token = await get_auth_token_interactively(timeout_seconds=60)

    if token:
        print(f"✅ Successfully captured token: {token[:8]}...")
        print("Authentication integration test PASSED")
    else:
        print("❌ Failed to capture token")
        print("Authentication integration test FAILED")

if __name__ == "__main__":
    asyncio.run(main())
EOF

# Run the integration test
uv run python test_auth_integration.py

# Expected: Browser opens, user can log in, token is captured
# If error: Check browser installation, network connectivity, login credentials
```

## Final validation Checklist
- [ ] All tests pass: `uv run pytest tests/ -v`
- [ ] No linting errors: `uv run ruff check src/`
- [ ] No type errors: `uv run mypy src/`
- [ ] Manual integration test successful: Browser opens and token captured
- [ ] EqcCrawler integration works: Can initialize crawler with captured token
- [ ] Error cases handled gracefully: Timeout, browser closed early, network issues
- [ ] Logs are informative but not verbose: Clear user guidance messages
- [ ] Backward compatibility maintained: Existing run.py usage still works

---

## Anti-Patterns to Avoid
- ❌ Don't use sync Playwright API - project uses async patterns
- ❌ Don't intercept all requests indefinitely - be specific about target APIs
- ❌ Don't ignore browser cleanup - always close browser instances
- ❌ Don't hardcode URLs and timeouts - make them configurable
- ❌ Don't break existing EqcCrawler compatibility
- ❌ Don't log sensitive token values in full - truncate for security
- ❌ Don't assume token format will never change - make extraction flexible

---

## Quality Assessment

### PRP Confidence Score: 9/10

**High confidence for one-pass implementation success** based on:

✅ **Complete Context**: All necessary Playwright documentation, existing codebase patterns, and integration points documented

✅ **Actionable Research**: Implementation-facing notes include specific commands, API decisions, and pitfall mitigations

✅ **Detailed Blueprint**: Step-by-step tasks with pseudocode showing exact implementation approach

✅ **Comprehensive Validation**: Three-level validation loop from syntax to integration testing

✅ **Project Integration**: Follows all CLAUDE.md conventions, async patterns, and existing authentication structures

✅ **Risk Mitigation**: Known gotchas documented with specific solutions for token format, browser cleanup, and network interception

**Minor Risk (-1 point)**: Integration testing requires manual user interaction which cannot be fully automated, but comprehensive mocking provides unit test coverage.

### Success Enablers
- Clear separation of concerns (auth module separate from existing crawler)
- Backward compatibility maintained through wrapper functions
- Extensive error handling and timeout management
- Security considerations (token truncation in logs)
- Production-ready patterns (async context managers, resource cleanup)

This PRP provides sufficient context and detail for an AI agent to implement the feature successfully in a single pass while maintaining code quality and project standards.