name: "Annuity Performance Discovery: Version-Aware File Selection with Chinese Naming"
description: |

## Purpose
Implement `latest_by_year_month_and_version` selection strategy for annuity performance data files stored in versioned directories (V1/, V2/, etc.), with robust handling of Chinese filenames and two-digit year normalization.

## Core Principles
1. **Context is King**: Include ALL necessary documentation, examples, and caveats
2. **Validation Loops**: Provide executable tests/lints the AI can run and fix
3. **Information Dense**: Use keywords and patterns from the codebase
4. **Progressive Success**: Start simple, validate, then enhance
5. **Global rules**: Be sure to follow all rules in CLAUDE.md

---

## Goal
Add `annuity_performance` domain to `data_sources.yml` and implement `latest_by_year_month_and_version` selection strategy in the file connector to pick the highest V* version within the same (year, month) grouping under `数据采集` directories.

## Why
- **Business value**: Enables automated processing of versioned annuity performance data with proper selection logic
- **Integration**: Extends existing file discovery system with version-aware capabilities
- **Problems solved**: Eliminates manual file selection when multiple versions exist for the same month

## What
A discovery configuration and selection strategy that:
- Matches annuity performance files with Chinese naming conventions
- Extracts version numbers from parent directory names (V1, V2, V10, etc.)
- Groups files by (normalized_year, month) and selects highest version
- Handles two-digit year normalization (24 → 2024)
- Falls back gracefully when version extraction fails

### Success Criteria
- [ ] `annuity_performance` domain present in `data_sources.yml` with correct pattern
- [ ] Connector selects highest V* version within (year, month) groups
- [ ] Two-digit year normalization applied (24 → 2024, but 2024 → 2024)
- [ ] Version extraction only applies when parent.parent.name == "数据采集"
- [ ] Graceful fallback to mtime when version parsing fails
- [ ] Unit tests verify grouping and selection logic
- [ ] All existing functionality remains unaffected

## All Needed Context

### Documentation & References
```yaml
# MUST READ - Include these in your context window
- file: src/work_data_hub/io/connectors/file_connector.py
  why: Core patterns for directory scanning, metadata extraction, selection strategies
  
- file: src/work_data_hub/config/data_sources.yml  
  why: Configuration format and existing domain patterns
  
- file: src/work_data_hub/utils/types.py
  why: DiscoveredFile dataclass structure and metadata handling
  
- file: tests/io/test_file_connector.py
  why: Test patterns and mocking approaches for connector functionality
  
- file: CLAUDE.md
  why: Code style, error handling, and testing standards

- url: https://docs.python.org/3/library/pathlib.html
  section: Path.glob and directory traversal patterns
  critical: Version directory parsing using Path.parent relationships
```

### Implementation-Facing Research Notes
```yaml
sources:
  - url: https://docs.python.org/3/library/pathlib.html#pathlib.Path.glob
    section: Path manipulation and parent directory access
    why: Version extraction from directory names
    type: docs

tldr:
  - Use Path.parent.name for directory name extraction
  - Simple string slicing with int() conversion for version parsing  
  - Tuple sorting (version, mtime) for robust comparison
  - Graceful ValueError handling for malformed versions
  - Unicode regex compilation with re.UNICODE flag

setup_commands:
  - "# No new dependencies needed - uses existing pathlib, re, yaml"
  - "# Test files go in tests/io/ following existing patterns"

api_decisions:
  - name: version_extraction_location
    choice: "_scan_directory_for_domain method"
    rationale: "Consistent with existing metadata extraction patterns"
  
  - name: version_storage
    choice: "metadata['version'] as Optional[int]"
    rationale: "Follows existing metadata dict pattern, allows None for fallback"
    
  - name: selection_strategy_name
    choice: "latest_by_year_month_and_version"
    rationale: "Clear, descriptive name following existing naming convention"

versions:
  - library: pathlib
    constraint: "stdlib"
    compatibility: "python 3.10+"
  
  - library: re
    constraint: "stdlib with re.UNICODE flag"
    compatibility: "handles Chinese characters properly"

pitfalls_and_mitigations:
  - issue: "Version strings like 'V1a' or 'VX' cause int() ValueError"
    mitigation: "try/except ValueError, set version=None for mtime fallback"
  
  - issue: "Unicode filename handling on Windows systems"
    mitigation: "Use re.UNICODE flag and UTF-8 encoding consistently"
    
  - issue: "Breaking existing selection strategies"
    mitigation: "Additive implementation - only affects new domain"
    
  - issue: "Two-digit vs four-digit year ambiguity"
    mitigation: "Explicit normalization: if year < 100: year += 2000"

open_questions:
  - "Should version extraction apply to other domains in future?"
  - "How to handle version numbers > 999 (V1000+)?"
```

### Current Codebase tree (key files for this feature)
```bash
src/work_data_hub/
├── config/
│   └── data_sources.yml           # Add annuity_performance domain here
├── io/
│   └── connectors/
│       └── file_connector.py      # Implement version selection logic
└── utils/
    └── types.py                   # DiscoveredFile structure (no changes)

tests/
└── io/
    └── test_file_connector.py     # Add version selection tests
```

### Desired Codebase tree with files to be added
```bash
# No new files - only modifications to existing files
tests/
└── legacy/
    └── test_annuity_performance_discovery.py  # New test file for domain-specific tests
```

### Known Gotchas & Library Quirks
```python
# CRITICAL: Unicode regex requires re.UNICODE flag for Chinese characters
# CRITICAL: Version extraction only when parent.parent.name == "数据采集"
# CRITICAL: Two-digit years need normalization: 24 → 2024, but 2024 → 2024  
# CRITICAL: Malformed versions (V1a, VX) should fallback to mtime, not crash
# CRITICAL: Path separator handling - use os.path.join or Path for cross-platform
# CRITICAL: Existing selection strategies must remain unchanged (additive only)
# PATTERN: Follow existing error handling with DataSourceConnectorError
# PATTERN: Use structured logging with logger.debug/info and extra= parameters
# PATTERN: Metadata extraction using extract_file_metadata() helper function
```

## Implementation Blueprint

### Data models and structure
```python
# No new models needed - extend existing DiscoveredFile metadata
# metadata will include:
# {
#   'version': Optional[int],  # Extracted from parent directory name
#   'year': int,               # Normalized year (24 → 2024)
#   'month': int,              # Extracted from filename pattern
#   # ... existing metadata fields
# }
```

### List of tasks to be completed

```yaml
Task 1: Add Annuity Performance Domain Configuration
MODIFY src/work_data_hub/config/data_sources.yml:
  - ADD annuity_performance domain after existing domains
  - PATTERN: Follow trustee_performance structure exactly
  - INCLUDE: description, pattern, select, sheet, table keys
  - USE: Unicode-aware regex for Chinese characters with named groups

Task 2: Implement Version Extraction Logic  
MODIFY src/work_data_hub/io/connectors/file_connector.py:
  - FIND: _scan_directory_for_domain method, metadata extraction section
  - ADD: Version extraction logic after existing year/month extraction
  - PATTERN: Check parent.parent.name == "数据采集" before version parsing
  - PRESERVE: All existing metadata extraction functionality

Task 3: Add New Selection Strategy
MODIFY src/work_data_hub/io/connectors/file_connector.py:
  - FIND: _apply_selection_strategies method
  - ADD: elif branch for "latest_by_year_month_and_version" strategy
  - PATTERN: Mirror existing strategy registration approach
  - DELEGATE: To new _select_latest_by_year_month_and_version method

Task 4: Implement Version-Aware Selection Method
MODIFY src/work_data_hub/io/connectors/file_connector.py:
  - CREATE: _select_latest_by_year_month_and_version method after existing selection methods
  - PATTERN: Follow _select_latest_by_year_month structure and error handling
  - LOGIC: Group by (year, month), sort by (version, mtime) descending within groups
  - FALLBACK: Handle None versions gracefully with mtime comparison

Task 5: Add Comprehensive Unit Tests
CREATE tests/legacy/test_annuity_performance_discovery.py:
  - PATTERN: Follow tests/io/test_file_connector.py structure and mocking approach
  - TEST: Version extraction from V1/, V2/, V10/ directories  
  - TEST: Malformed version handling (VX, V1a, etc.)
  - TEST: Year normalization (24 → 2024)
  - TEST: Selection within (year, month) groups
  - TEST: Fallback behavior when version=None
  - MARK: Use @pytest.mark.legacy_data for opt-in testing

Task 6: Add Integration Tests to Existing Test Suite
MODIFY tests/io/test_file_connector.py:
  - ADD: Test method for new selection strategy using existing patterns
  - PATTERN: Follow test_latest_by_year_month_selection structure
  - CREATE: Temporary directory with V1/, V2/ structure and Chinese filenames
  - VERIFY: Correct version selection and fallback behavior
```

### Per task pseudocode

```python
# Task 2: Version Extraction Logic (in _scan_directory_for_domain)
# Add after existing year/month extraction:
parent = Path(file_path).parent
version = None
if parent.name.upper().startswith("V") and parent.parent.name == "数据采集":
    try:
        version = int(parent.name[1:])  # Extract number after 'V'
    except ValueError:
        version = None  # Fallback for malformed versions like 'VX'
        logger.debug(f"Malformed version in {parent.name}, falling back to mtime")

# Add version to metadata
file_metadata.update({
    'version': version,
    **groups  # existing regex groups
})

# Task 3: Year Normalization (modify existing year extraction)  
year = int(groups["year"]) if "year" in groups and groups["year"] else None
if year and year < 100:  # Two-digit year normalization
    year = 2000 + year

# Task 4: Version-Aware Selection Method
def _select_latest_by_year_month_and_version(self, files: List[DiscoveredFile]) -> List[DiscoveredFile]:
    """
    Select latest file by year/month/version, with mtime fallback.
    
    Groups files by (year, month) and selects file with highest 
    (version, mtime) tuple within each group.
    """
    if not files:
        return []
    
    # Group by (year, month) - same as existing method
    from itertools import groupby
    from operator import attrgetter
    
    # Sort first by year/month for grouping
    sorted_files = sorted(files, key=lambda f: (f.year or 0, f.month or 0))
    
    selected = []
    for (year, month), group_files in groupby(sorted_files, key=lambda f: (f.year, f.month)):
        group_list = list(group_files)
        
        # Within group, select by (version, mtime) descending
        try:
            best_file = max(group_list, key=lambda f: (
                f.metadata.get('version') or 0,  # None versions get 0
                Path(f.path).stat().st_mtime
            ))
            selected.append(best_file)
        except (OSError, FileNotFoundError) as e:
            logger.error(f"Error accessing file modification times in version selection: {e}")
            # Fallback to first file if stat() fails
            if group_list:
                selected.append(group_list[0])
    
    return selected
```

### Integration Points
```yaml
CONFIG_UPDATE:
  - file: src/work_data_hub/config/data_sources.yml
  - add_domain: |
      annuity_performance:
        description: "Annuity performance (规模明细) with version-aware selection"
        pattern: "(?P<year>\\d{2}|20\\d{2})年(?P<month>0?[1-9]|1[0-2])月.*年金.*终稿数据.*\\.(xlsx|xlsm)$"
        select: "latest_by_year_month_and_version"  
        sheet: "规模明细"
        table: "规模明细"

CONNECTOR_INTEGRATION:
  - method: _scan_directory_for_domain
  - integration: Version extraction after existing metadata
  - method: _apply_selection_strategies  
  - integration: New strategy branch for version-aware selection

LOGGING_INTEGRATION:
  - pattern: logger.debug() for version extraction details
  - pattern: logger.info() for selection results with version context
  - include: version numbers in structured logging extras
```

## Validation Loop

### Level 1: Syntax & Style
```bash
# Run these FIRST - fix any errors before proceeding
uv run ruff check src/ --fix
uv run mypy src/
uv run ruff check tests/ --fix

# Expected: No errors. If errors, READ the error and fix.
```

### Level 2: Unit Tests 
```python
# tests/legacy/test_annuity_performance_discovery.py
import pytest
from pathlib import Path
from src.work_data_hub.io.connectors.file_connector import DataSourceConnector

@pytest.mark.legacy_data
def test_version_extraction_from_directory(tmp_path, monkeypatch):
    """Test version extraction from V* directory names."""
    # Create structure: 数据采集/V2/24年11月年金终稿数据.xlsx
    data_dir = tmp_path / "数据采集" / "V2"
    data_dir.mkdir(parents=True)
    test_file = data_dir / "24年11月年金终稿数据.xlsx"  
    test_file.write_text("test")
    
    monkeypatch.setenv("WDH_DATA_BASE_DIR", str(tmp_path))
    
    connector = DataSourceConnector()
    files = connector.discover("annuity_performance")
    
    assert len(files) == 1
    assert files[0].metadata['version'] == 2
    assert files[0].year == 2024  # Normalized from 24
    assert files[0].month == 11

@pytest.mark.legacy_data  
def test_version_selection_within_month(tmp_path, monkeypatch):
    """Test selection of highest version within same month."""
    # Create V1 and V2 directories with same month files
    v1_dir = tmp_path / "数据采集" / "V1"
    v2_dir = tmp_path / "数据采集" / "V2" 
    
    for vdir in [v1_dir, v2_dir]:
        vdir.mkdir(parents=True)
        (vdir / "24年11月年金终稿数据.xlsx").write_text("test")
    
    monkeypatch.setenv("WDH_DATA_BASE_DIR", str(tmp_path))
    
    connector = DataSourceConnector()
    files = connector.discover("annuity_performance")
    
    # Should only return V2 file (highest version)
    assert len(files) == 1
    assert files[0].metadata['version'] == 2
    assert "V2" in files[0].path

def test_malformed_version_fallback(tmp_path, monkeypatch):
    """Test fallback to mtime when version is malformed.""" 
    # Create directories with malformed versions
    bad_dir = tmp_path / "数据采集" / "VX"
    good_dir = tmp_path / "数据采集" / "V1"
    
    bad_dir.mkdir(parents=True)
    good_dir.mkdir(parents=True)
    
    # Same filename in both
    (bad_dir / "24年11月年金终稿数据.xlsx").write_text("test")
    (good_dir / "24年11月年金终稿数据.xlsx").write_text("test")
    
    monkeypatch.setenv("WDH_DATA_BASE_DIR", str(tmp_path))
    
    connector = DataSourceConnector()  
    files = connector.discover("annuity_performance")
    
    # Should return V1 file (valid version beats None version)
    assert len(files) == 1
    assert files[0].metadata['version'] == 1
```

```bash
# Run tests iteratively until passing:
uv run pytest tests/legacy/test_annuity_performance_discovery.py -v
uv run pytest tests/io/test_file_connector.py -k "version" -v

# If failing: Read error, understand root cause, fix code, re-run
```

### Level 3: Integration Test
```bash
# Test end-to-end discovery with realistic file structure
# Create test data structure (manual verification):
mkdir -p "test_data/数据采集/V1"
mkdir -p "test_data/数据采集/V2"
echo "test" > "test_data/数据采集/V1/24年11月年金终稿数据1209采集.xlsx"
echo "test" > "test_data/数据采集/V2/24年11月年金终稿数据1210采集.xlsx"

# Set environment and test discovery
export WDH_DATA_BASE_DIR="./test_data"
uv run python -c "
from src.work_data_hub.io.connectors.file_connector import DataSourceConnector
connector = DataSourceConnector()
files = connector.discover('annuity_performance')
print(f'Found {len(files)} files')
for f in files:
    print(f'  {f.path} (version={f.metadata.get(\"version\")}, year={f.year}, month={f.month})')
"

# Expected: Only V2 file selected, version=2, year=2024, month=11
```

## Final Validation Checklist
- [ ] All tests pass: `uv run pytest -v -k annuity_performance_discovery`
- [ ] All tests pass: `uv run pytest -m legacy_data -v -k discovery`  
- [ ] No linting errors: `uv run ruff check src/ --fix`
- [ ] No type errors: `uv run mypy src/`
- [ ] Manual integration test shows correct version selection
- [ ] Existing trustee_performance discovery still works unchanged
- [ ] Version extraction only occurs under "数据采集" directories
- [ ] Two-digit year normalization works correctly (24→2024)
- [ ] Malformed versions fall back to mtime gracefully
- [ ] Logs show clear version selection reasoning

---

## Anti-Patterns to Avoid
- ❌ Don't break existing selection strategies - implementation must be additive
- ❌ Don't extract versions from non-"数据采集" directories 
- ❌ Don't crash on malformed version strings - fallback gracefully
- ❌ Don't hardcode version limits - handle V1 through V999+ robustly
- ❌ Don't ignore Unicode handling for Chinese filenames
- ❌ Don't skip year normalization - handle both 2-digit and 4-digit years
- ❌ Don't forget structured logging with version context

## Confidence Score: 8/10

High confidence due to:
- Clear existing patterns in DataSourceConnector to follow
- Well-established test structure and mocking approaches  
- Unicode handling patterns already proven in trustee_performance
- Additive implementation reduces risk of breaking changes
- Comprehensive validation gates with specific test cases

Minor uncertainty around:
- Edge cases in version parsing (V10+, V999+)  
- Chinese filename handling across different OS environments
- Performance impact of additional metadata extraction (should be minimal)

The implementation follows established codebase patterns with clear fallback strategies for edge cases.