# Story 7.1-17: Reduce Function Complexity

Status: backlog

## Story

As a **Software Engineer**,
I want **complex functions refactored into smaller, focused units**,
so that **code is testable, maintainable, and easier to understand**.

## Context

**Priority:** P1 (HIGH - Design Quality)
**Effort:** 2-3 hours
**Epic:** 7.1 - Pre-Epic 8 Bug Fixes & Improvements
**Source:** [Ruff Warning Triage Analysis](../reviews/ruff-warning-triage-7.1-10.md)

### Problem Statement

**96 function complexity violations** exist across 4 PLR rules:

| Rule | Count | Description | Threshold |
|------|-------|-------------|-----------|
| **PLR0915** | 32 | Too many statements (>50) | Functions doing too much |
| **PLR0913** | 30 | Too many arguments (6+) | Design smell - needs dataclass |
| **PLR0912** | 25 | Too many branches (>12) | High cyclomatic complexity |
| **PLR0911** | 9 | Too many return statements | Control flow complexity |

**Total Refactoring Effort:** 96 functions → Estimated 2-3 hours

### Why This Matters

**Code Maintainability:**
- Complex functions are hard to understand and debug
- High branching indicates missing abstraction
- Too many arguments suggest need for dataclass/config object

**Testing Standards:**
- Complex functions require many test cases
- Hard to mock and isolate dependencies
- Integration tests become brittle

**Epic 8 Readiness:**
- Classification-Based Validation requires modular code
- Test coverage easier with smaller functions
- Refactoring now reduces Epic 8 complexity

## Acceptance Criteria

### AC-1: Refactor PLR0915 (Too Many Statements)

**GIVEN** 32 functions have >50 statements
**WHEN** refactored into smaller helpers
**THEN** each function has <50 statements

**Fix Strategy:**

1. **Extract Logical Blocks:**
   ```python
   # ❌ WRONG: 100+ statement function
   def process_annuity_performance(data, config):
       # ... 50+ lines of validation
       # ... 30+ lines of transformation
       # ... 20+ lines of loading
       pass

   # ✅ CORRECT: Extracted helpers
   def process_annuity_performance(data, config):
       validated = _validate_data(data, config)
       transformed = _transform_data(validated, config)
       _load_to_database(transformed, config)
   ```

2. **Use Command Pattern for Workflows:**
   ```python
   class PipelineStep(Protocol):
       def execute(self, context: PipelineContext) -> None: ...

   def run_pipeline(steps: List[PipelineStep], context: PipelineContext):
       for step in steps:
           step.execute(context)
   ```

**Deliverable:** 32 functions refactored to <50 statements each

---

### AC-2: Refactor PLR0913 (Too Many Arguments)

**GIVEN** 30 functions have 6+ parameters
**WHEN** refactored to use dataclasses
**THEN** each function has <6 parameters

**Fix Strategy:**

1. **Introduce Dataclass/Config Object:**
   ```python
   # ❌ WRONG: 7 parameters
   def process_data(
       source: str,
       target: str,
       batch_size: int,
       timeout: int,
       retry_count: int,
       verbose: bool,
       dry_run: bool
   ):
       pass

   # ✅ CORRECT: Config object
   @dataclass
   class ProcessConfig:
       source: str
       target: str
       batch_size: int = 100
       timeout: int = 30
       retry_count: int = 3
       verbose: bool = False
       dry_run: bool = False

   def process_data(config: ProcessConfig):
       pass
   ```

2. **Use Builder Pattern for Complex Objects:**
   ```python
   class ProcessConfigBuilder:
       def __init__(self):
           self._config = {}

       def with_source(self, source: str):
           self._config['source'] = source
           return self

       def build(self) -> ProcessConfig:
           return ProcessConfig(**self._config)
   ```

**Deliverable:** 30 functions refactored to <6 parameters each

---

### AC-3: Refactor PLR0912 (Too Many Branches)

**GIVEN** 25 functions have >12 branches
**WHEN** refactored to use strategy/lookup patterns
**THEN** each function has <12 branches

**Fix Strategy:**

1. **Use Strategy Pattern:**
   ```python
   # ❌ WRONG: 15+ if/elif branches
   def process_record(record):
       if record['type'] == 'annuity_performance':
           # ... 20 lines
       elif record['type'] == 'annuity_income':
           # ... 20 lines
       elif record['type'] == 'portfolio_plans':
           # ... 20 lines
       # ... 12 more elif branches

   # ✅ CORRECT: Strategy pattern
   class RecordProcessor(Protocol):
       def process(self, record: dict) -> dict: ...

   PROCESSORS: Dict[str, RecordProcessor] = {
       'annuity_performance': AnnuityPerformanceProcessor(),
       'annuity_income': AnnuityIncomeProcessor(),
       'portfolio_plans': PortfolioPlansProcessor(),
   }

   def process_record(record):
       processor = PROCESSORS.get(record['type'])
       if processor is None:
           raise ValueError(f"Unknown type: {record['type']}")
       return processor.process(record)
   ```

2. **Use Lookup Tables:**
   ```python
   # ❌ WRONG: 10+ if/elif for field mapping
   def get_field_mapping(domain_name):
       if domain_name == 'annuity_performance':
           return {...}
       elif domain_name == 'annuity_income':
           return {...}
       # ... 8 more branches

   # ✅ CORRECT: Lookup table
   FIELD_MAPPINGS: Dict[str, Dict[str, str]] = {
       'annuity_performance': {...},
       'annuity_income': {...},
   }

   def get_field_mapping(domain_name):
       return FIELD_MAPPINGS.get(domain_name, {})
   ```

**Deliverable:** 25 functions refactored to <12 branches each

---

### AC-4: Refactor PLR0911 (Too Many Returns)

**GIVEN** 9 functions have >8 return statements
**WHEN** refactored to consolidate returns
**THEN** each function has <8 returns

**Fix Strategy:**

1. **Early Exit Pattern:**
   ```python
   # ❌ WRONG: 10+ return statements scattered
   def validate_record(record):
       if not record:
           return None
       if 'id' not in record:
           return None
       if 'name' not in record:
           return None
       # ... 7 more similar checks
       return record

   # ✅ CORRECT: Guard clauses with single exit
   def validate_record(record):
       """Validate and return record, or None if invalid."""
       if not record:
           return None
       if 'id' not in record or 'name' not in record:
           return None
       # ... consolidate similar checks
       return record if is_valid(record) else None
   ```

2. **Extract Complex Conditions:**
   ```python
   def _is_valid_record(record: dict) -> bool:
       """Check if record has required fields."""
       required_fields = ['id', 'name', 'date']
       return all(field in record for field in required_fields)
   ```

**Deliverable:** 9 functions refactored to <8 returns each

---

### AC-5: Run Ruff Verification

**GIVEN** complexity refactoring is complete
**WHEN** `ruff check --select PLR09` is run
**THEN** 0 PLR09 violations remain

**Verification Command:**

```bash
# Check for remaining complexity violations
PYTHONPATH=src uv run --env-file .wdh_env ruff check src/ --select PLR09

# Expected: 0 violations
```

**Deliverable:** `ruff check --select PLR09` passes

---

### AC-6: Verify No Regressions

**GIVEN** functions are refactored
**WHEN** test suite is run
**THEN** all tests pass (no behavior changes)

**Verification:**

```bash
# Run full test suite
PYTHONPATH=src uv run --env-file .wdh_env pytest tests/ -v

# Expected: All tests pass (refactoring preserves behavior)
```

**Deliverable:** Test suite passes with no failures

---

## Tasks / Subtasks

- [ ] **Task 1: Analyze and Prioritize Complexity Violations** (AC-1)
  - [ ] 1.1 Run `ruff check src/ --select PLR09 --output-format=json > complexity_analysis.json`
  - [ ] 1.2 Parse JSON and group violations by file
  - [ ] 1.3 Prioritize by impact (domain layer > infrastructure > IO)
  - [ ] 1.4 Create refactoring plan (high-impact functions first)

- [ ] **Task 2: Refactor PLR0915 (Too Many Statements)** (AC-1)
  - [ ] 2.1 Identify 32 functions with >50 statements
  - [ ] 2.2 Extract logical blocks into private helpers
  - [ ] 2.3 Apply command pattern for workflow functions
  - [ ] 2.4 Verify each function has <50 statements

- [ ] **Task 3: Refactor PLR0913 (Too Many Arguments)** (AC-2)
  - [ ] 3.1 Identify 30 functions with 6+ parameters
  - [ ] 3.2 Create dataclasses/config objects for parameter groups
  - [ ] 3.3 Update function signatures to accept config objects
  - [ ] 3.4 Update call sites to construct config objects

- [ ] **Task 4: Refactor PLR0912 (Too Many Branches)** (AC-3)
  - [ ] 4.1 Identify 25 functions with >12 branches
  - [ ] 4.2 Extract strategy classes for conditional logic
  - [ ] 4.3 Use lookup tables for dispatch logic
  - [ ] 4.4 Apply guard clauses to reduce nesting

- [ ] **Task 5: Refactor PLR0911 (Too Many Returns)** (AC-4)
  - [ ] 5.1 Identify 9 functions with >8 returns
  - [ ] 5.2 Consolidate returns with early exit pattern
  - [ ] 5.3 Extract complex conditions to helper functions
  - [ ] 5.4 Verify single-responsibility principle

- [ ] **Task 6: Verification** (AC-5, AC-6)
  - [ ] 6.1 Run `ruff check src/ --select PLR09`
  - [ ] 6.2 Verify 0 violations remain
  - [ ] 6.3 Run full test suite
  - [ ] 6.4 Verify no behavior changes (all tests pass)

## Dev Notes

### Refactoring Strategy

**Phase 1: Analysis (15 minutes)**
- Parse PLR09 JSON output
- Group violations by file and layer
- Prioritize high-impact functions (domain layer first)

**Phase 2: Refactoring (90-135 minutes)**
- Start with PLR0913 (easiest - dataclass conversion)
- Move to PLR0911 (consolidate returns)
- Address PLR0912 (strategy pattern)
- Finish with PLR0915 (extract helpers - most time-consuming)

**Phase 3: Verification (15 minutes)**
- Ruff check for PLR09
- Run full test suite
- Spot-check critical paths

### Refactoring Patterns

**1. Dataclass Conversion (PLR0913):**
```python
# Before: 8 parameters
def load_data(source, target, batch, timeout, retry, verbose, dry_run, validate):
    pass

# After: 1 parameter
@dataclass
class LoadConfig:
    source: str
    target: str
    batch_size: int = 100
    timeout: int = 30
    retry_count: int = 3
    verbose: bool = False
    dry_run: bool = False
    validate: bool = True

def load_data(config: LoadConfig):
    pass
```

**2. Strategy Pattern (PLR0912):**
```python
# Before: 15+ branches
def process_by_type(record):
    if record['type'] == 'A': ...
    elif record['type'] == 'B': ...
    # ... 13 more branches

# After: Lookup table
PROCESSORS = {
    'A': ProcessorA(),
    'B': ProcessorB(),
}

def process_by_type(record):
    processor = PROCESSORS.get(record['type'])
    if not processor:
        raise ValueError(f"Unknown type: {record['type']}")
    return processor.process(record)
```

**3. Extract Helpers (PLR0915):**
```python
# Before: 80 statements
def process_etl(config):
    # ... 30 lines: validation
    # ... 30 lines: transformation
    # ... 20 lines: loading

# After: 3 functions with <30 statements each
def process_etl(config):
    data = _validate_and_load(config)
    transformed = _transform_data(data, config)
    _load_to_database(transformed, config)
```

### Testing Standards

**After Refactoring:**
```bash
# Verify PLR09 eliminated
PYTHONPATH=src uv run --env-file .wdh_env ruff check src/ --select PLR09

# Run full test suite
PYTHONPATH=src uv run --env-file .wdh_env pytest tests/ -v

# Verify integration tests still pass
PYTHONPATH=src uv run --env-file .wdh_env pytest tests/integration/ -v
```

### References

- [Ruff Warning Triage](../reviews/ruff-warning-triage-7.1-10.md) - Section P1 High: PLR09xx
- [Project Context](../project-context.md) - Section 4: Design Principles (KISS, SRP)
- [Clean Code](https://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882) - Chapter 3: Functions

## Dev Agent Record

### Agent Model Used

Claude Opus 4.5 (claude-opus-4-5-20251101)

### Completion Notes List

**Story Created:** 2025-12-26
**Context Source:** Ruff Warning Triage Analysis (Story 7.1-10)

**Story Approach:**
- **Design Quality:** P1 - High priority for maintainability
- **Incremental Refactor:** 96 functions across 4 complexity rules
- **Pattern-Based:** Use dataclasses, strategies, extraction patterns

### File List

**Files to Analyze:**
- All files with PLR09 violations (from `ruff check --select PLR09`)

**Files to Modify (Estimated):**
- Multiple domain service files (~40 violations)
- Multiple infrastructure files (~30 violations)
- Multiple IO layer files (~20 violations)
- Multiple CLI files (~6 violations)

**Analysis Artifacts:**
- `complexity_analysis.json` (temporary, for prioritization)

---

## Validation Record

**Validated:** 2025-12-26
**Validator:** Dev Agent (Story 7.1-10 Analysis)
**Validation Source:** Ruff Warning Triage - PLR09xx Analysis

**Criteria Met:**
- ✅ 96 PLR09 violations > 5 threshold (story creation triggered)
- ✅ High priority (P1) identified
- ✅ Effort estimate: 2-3 hours
- ✅ Refactoring patterns documented
