# Story 7.6-6: Contract Status Sync (Post-ETL Hook)

Status: ready-for-dev

## At a Glance

| Attribute | Value |
|-----------|-------|
| **Goal** | Create `customer.customer_plan_contract` table and implement Post-ETL hook for automatic contract status sync |
| **Impact** | Enables customer-plan contract tracking with SCD Type 2 history, auto-refreshes after business ETL |
| **Risk** | Medium (new table creation + CLI integration + orchestration hook pattern) |
| **Dependencies** | Stories 7.6-0 to 7.6-5 (customer schema exists, 中标/流失 data loaded), Epic 6.2 (FK backfill infrastructure) |
| **Effort** | 1.5 days |
| **Rollback** | `DROP TABLE customer.customer_plan_contract CASCADE;` - can recreate via migration |

## Story

As a **BI Analyst**,
I want **customer-plan contract relationships and status to be automatically synced after business ETL runs**,
so that **I can query current and historical customer contract status without manual intervention**.

## Acceptance Criteria

### Table Creation (AC-1)

**AC-1**: Create `customer.customer_plan_contract` table via Alembic migration
- Schema: `customer` (already exists from Story 7.6-0)
- Implements SCD Type 2 with `valid_from`/`valid_to` columns
- Includes business key: `(company_id, plan_code, product_line_code)`
- Includes annual status: `is_strategic`, `is_existing`, `status_year`
- Includes monthly status: `contract_status` (正常/停缴)
- All required indexes created (see Dev Notes for DDL)

### Data Population (AC-2)

**AC-2**: Populate initial contract data from `business.规模明细`
- Source: `business.规模明细` table (existing ETL output)
- Business key derivation: `company_id + 计划代码 + 产品线代码`
- Contract status logic:
  - `正常`: `期末资产规模 > 0`
  - `停缴`: `期末资产规模 = 0`
- Set `valid_from` to snapshot month-end date
- Set `valid_to` to `9999-12-31` for current records

### Post-ETL Hook Infrastructure (AC-3)

**AC-3**: Implement Post-ETL Hook pattern for automatic sync
- Create `src/work_data_hub/cli/etl/hooks.py` module
- Register contract sync as a post-ETL hook
- Hook triggers after `annuity_performance` domain ETL completes
- Hook execution is idempotent (safe to re-run)
- CLI flag `--no-post-hooks` available to skip hooks

### Manual Trigger Support (AC-4)

**AC-4**: Provide manual CLI command for contract sync
- Command: `uv run --env-file .wdh_env python -m work_data_hub.cli customer-mdm sync`
- Logs progress and record counts
- Uses same sync logic as Post-ETL hook

### Data Quality (AC-5)

**AC-5**: Validate populated data
- All records have non-null `company_id`, `plan_code`, `product_line_code`
- All `product_line_code` values exist in `mapping.产品线`
- `contract_status` contains only valid values (正常/停缴)

## Tasks / Subtasks

- [ ] Task 1: Create Alembic migration for `customer_plan_contract` table (AC: 1)
  - [ ] Create migration file `008_create_customer_plan_contract.py`
  - [ ] Define table DDL with columns, constraints, indexes
  - [ ] Add `updated_at` trigger function
  - [ ] Run migration and verify table creation

- [ ] Task 2: Implement Contract Status Sync Service (AC: 2, 5)
  - [ ] Create `src/work_data_hub/customer_mdm/contract_sync.py`
  - [ ] Implement `sync_contract_status()` function
  - [ ] Derive business key from `business.规模明细`
  - [ ] Calculate contract_status based on 期末资产规模
  - [ ] Use UPSERT (ON CONFLICT) for idempotent writes

- [ ] Task 3: Create Post-ETL Hooks Module (AC: 3)
  - [ ] Create `src/work_data_hub/cli/etl/hooks.py`
  - [ ] Define `PostEtlHook` protocol/dataclass
  - [ ] Implement `run_post_etl_hooks()` function
  - [ ] Register `contract_sync` hook for `annuity_performance` domain
  - [ ] Integrate hook execution into ETL pipeline (`executors.py`)

- [ ] Task 4: Add `--no-post-hooks` CLI flag (AC: 3)
  - [ ] Update `src/work_data_hub/cli/etl/main.py` with new flag
  - [ ] Pass flag through to executor
  - [ ] Skip hooks when flag is set

- [ ] Task 5: Create Customer MDM CLI subcommand (AC: 4)
  - [ ] Create `src/work_data_hub/cli/customer_mdm/` package
  - [ ] Implement `sync` subcommand
  - [ ] Register in `__main__.py`

- [ ] Task 6: Validation and Testing (AC: 5)
  - [ ] Run initial sync and verify record counts
  - [ ] Validate FK relationships with `mapping.产品线`
  - [ ] Test idempotency (run sync multiple times)
  - [ ] Verify `--no-post-hooks` flag works

## Dev Notes

### Architecture Compliance

- **Follows Post-ETL Hook Pattern** from [Sprint Change Proposal](file:///e:/Projects/WorkDataHub/docs/project-planning-artifacts/sprint-change-proposal-2026-01-10.md#42-etl-integration-architecture-post-etl-hook-pattern)
- **CLI Conventions**: Subpackage pattern per Epic 7 CLI modularization
- **Migration Pattern**: See existing migrations in `io/schema/migrations/versions/`

### Table DDL (from Specification v0.6)

```sql
CREATE TABLE customer.customer_plan_contract (
    -- Primary key
    contract_id SERIAL PRIMARY KEY,

    -- Business dimension (compound business key)
    company_id VARCHAR NOT NULL,
    plan_code VARCHAR NOT NULL,
    product_line_code VARCHAR(20) NOT NULL,

    -- Redundant fields (for query convenience)
    product_line_name VARCHAR(50) NOT NULL,

    -- Annual initialization status (updated every January)
    is_strategic BOOLEAN DEFAULT FALSE,
    is_existing BOOLEAN DEFAULT FALSE,
    status_year INTEGER NOT NULL,

    -- Monthly update status
    contract_status VARCHAR(20) NOT NULL,

    -- SCD Type 2 time dimension (end of month)
    valid_from DATE NOT NULL,
    valid_to DATE DEFAULT '9999-12-31',

    -- Audit fields
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,

    -- Foreign key constraints
    CONSTRAINT fk_contract_company FOREIGN KEY (company_id)
        REFERENCES mapping."年金客户"(company_id),
    CONSTRAINT fk_contract_product_line FOREIGN KEY (product_line_code)
        REFERENCES mapping."产品线"(产品线代码),

    -- Compound unique constraint (business key + time)
    CONSTRAINT uq_active_contract UNIQUE (company_id, plan_code, product_line_code, valid_to)
);

-- Indexes
CREATE INDEX idx_contract_company ON customer.customer_plan_contract(company_id);
CREATE INDEX idx_contract_plan ON customer.customer_plan_contract(plan_code);
CREATE INDEX idx_contract_product_line ON customer.customer_plan_contract(product_line_code);
CREATE INDEX idx_contract_strategic ON customer.customer_plan_contract(is_strategic) WHERE is_strategic = TRUE;
CREATE INDEX idx_contract_status_year ON customer.customer_plan_contract(status_year);
CREATE INDEX idx_active_contracts ON customer.customer_plan_contract(company_id, plan_code, product_line_code)
    WHERE valid_to = '9999-12-31';
CREATE INDEX idx_contract_valid_from_brin ON customer.customer_plan_contract USING BRIN (valid_from);
```

### Contract Status Logic (v1 Simplified)

```python
def determine_contract_status(期末资产规模: Decimal) -> str:
    """Determine contract status based on end-of-period AUM.
    
    NOTE: This is v1 simplified logic. Full v2 logic (12-month rolling window)
    is defined in specification v0.6 §4.3.1-4.3.2 and will be implemented
    when 供款 data is available.
    """
    if 期末资产规模 > 0:
        return "正常"  # Active
    return "停缴"  # Suspended
```

> [!NOTE]
> Story 7.6-7 (Monthly Snapshot Refresh) will add `is_winning_this_year` and `is_churned_this_year` flags to `fct_customer_business_monthly_status` table, NOT this table.

### is_strategic / is_existing Initialization

> [!IMPORTANT]
> For Story 7.6-6 (v1), initialize placeholder values:
> - `is_strategic = FALSE` — Full logic implemented in Story 7.6-9
> - `is_existing = FALSE` — Full logic implemented in Story 7.6-9  
> - `status_year = EXTRACT(YEAR FROM CURRENT_DATE)`

### Post-ETL Hook Pattern

**Hook Registration** (`hooks.py`):

```python
from dataclasses import dataclass
from typing import Callable, List

@dataclass
class PostEtlHook:
    """A hook that runs after ETL completion for a domain."""
    name: str
    domains: List[str]  # Which domains trigger this hook
    hook_fn: Callable[[str, str], None]  # (domain, period) -> None

# Registry of post-ETL hooks
POST_ETL_HOOKS: List[PostEtlHook] = [
    PostEtlHook(
        name="contract_status_sync",
        domains=["annuity_performance"],
        hook_fn=sync_contract_status,
    ),
]
```

**Hook Execution** (in `executors.py` after domain ETL):

```python
# Insert AFTER line 379 in _execute_single_domain(), inside the `if result.success:` block:
if not getattr(args, 'no_post_hooks', False):
    from .hooks import run_post_etl_hooks
    run_post_etl_hooks(domain=domain, period=getattr(args, 'period', None))
```

### File Structure

```
src/work_data_hub/
├── cli/
│   ├── etl/
│   │   ├── hooks.py          # [NEW] Post-ETL hook registry and runner
│   │   ├── main.py           # [MODIFY] Add --no-post-hooks flag
│   │   └── executors.py      # [MODIFY] Call run_post_etl_hooks()
│   └── customer_mdm/         # [NEW] Customer MDM CLI package
│       ├── __init__.py
│       └── sync.py           # Manual sync command
├── customer_mdm/             # [NEW] Customer MDM service package
│   ├── __init__.py
│   └── contract_sync.py      # Sync service implementation
└── io/
    └── schema/
        └── migrations/
            └── versions/
                └── 008_create_customer_plan_contract.py  # [NEW]
```

### Previous Story Intelligence (Story 7.6-5)

**Key Learnings from Historical Data Backfill:**
- Sheet names in source Excel matched config exactly (no adjustment needed)
- 100% company_id fill rate achieved via enrichment
- Use existing CLI patterns for consistency
- Alembic migrations follow `00X_xxx.py` naming

**Git commit patterns:**
- `feat(schema):` for schema changes
- `feat(customer):` for customer domain changes
- `feat(cli):` for CLI additions

### Reference SQL for Initial Population

```sql
-- Initial population from business.规模明细
INSERT INTO customer.customer_plan_contract (
    company_id, plan_code, product_line_code, product_line_name,
    is_strategic, is_existing, status_year, contract_status,
    valid_from, valid_to
)
SELECT DISTINCT
    s.company_id,
    s.计划代码 as plan_code,
    s.产品线代码 as product_line_code,
    COALESCE(p.产品线, s.业务类型) as product_line_name,
    FALSE as is_strategic,      -- Placeholder, Story 7.6-9 implements full logic
    FALSE as is_existing,       -- Placeholder, Story 7.6-9 implements full logic
    EXTRACT(YEAR FROM s.月度) as status_year,
    CASE WHEN s.期末资产规模 > 0 THEN '正常' ELSE '停缴' END as contract_status,
    (date_trunc('month', s.月度) + interval '1 month - 1 day')::date as valid_from,
    '9999-12-31'::date as valid_to
FROM business.规模明细 s
LEFT JOIN mapping."产品线" p ON s.产品线代码 = p.产品线代码
WHERE s.company_id IS NOT NULL
  AND s.产品线代码 IS NOT NULL
  AND s.计划代码 IS NOT NULL
ON CONFLICT (company_id, plan_code, product_line_code, valid_to) DO NOTHING;
```

### CLI Commands

```bash
# Run ETL with hooks (default)
uv run --env-file .wdh_env python -m work_data_hub.cli etl \
  --domain annuity_performance --execute

# Run ETL without hooks (debugging)
uv run --env-file .wdh_env python -m work_data_hub.cli etl \
  --domain annuity_performance --execute --no-post-hooks

# Manual sync command
uv run --env-file .wdh_env python -m work_data_hub.cli customer-mdm sync
```

### Validation Queries

```sql
-- Query 1: Total record count
SELECT COUNT(*) FROM customer.customer_plan_contract;

-- Query 2: Distribution by contract_status
SELECT contract_status, COUNT(*) FROM customer.customer_plan_contract
GROUP BY contract_status;

-- Query 3: Distribution by product_line_code
SELECT product_line_code, product_line_name, COUNT(*)
FROM customer.customer_plan_contract
GROUP BY product_line_code, product_line_name
ORDER BY product_line_code;

-- Query 4: FK validation (should return 0)
SELECT COUNT(*) FROM customer.customer_plan_contract c
LEFT JOIN mapping."产品线" p ON c.product_line_code = p.产品线代码
WHERE p.产品线代码 IS NULL;

-- Query 5: Sample active contracts
SELECT * FROM customer.customer_plan_contract
WHERE valid_to = '9999-12-31'
ORDER BY created_at DESC
LIMIT 10;
```

### Configuration File

**Path**: `config/customer_mdm.yaml` — **[NEW FILE] Create this file**

```yaml
customer_mdm:
  # Strategic customer threshold (5 billion yuan)
  strategic_threshold: 500000000
  # Top N customers per branch for whitelist
  whitelist_top_n: 10
  # Current status year
  status_year: 2026
```

> [!TIP]
> Create this configuration file during Task 1. The values are placeholders for Story 7.6-9. Full strategic customer logic (`is_strategic`, `is_existing`) will be implemented in Story 7.6-9 (Index & Trigger Optimization).

### Project Structure Notes

- **Follows Epic 7 modularization**: New code in dedicated packages, not large monolithic files
- **CLI package pattern**: `cli/customer_mdm/` mirrors existing `cli/etl/`
- **Service layer separation**: Business logic in `customer_mdm/` package, CLI in `cli/customer_mdm/`

### References

- [Source: docs/specific/customer-mdm/customer-plan-contract-specification.md](file:///e:/Projects/WorkDataHub/docs/specific/customer-mdm/customer-plan-contract-specification.md)
- [Source: docs/project-planning-artifacts/sprint-change-proposal-2026-01-10.md#4.2](file:///e:/Projects/WorkDataHub/docs/project-planning-artifacts/sprint-change-proposal-2026-01-10.md)
- [Source: scripts/seed_data/seed_customer_plan_contract.py](file:///e:/Projects/WorkDataHub/scripts/seed_data/seed_customer_plan_contract.py)
- [Source: docs/sprint-artifacts/stories/epic-customer-mdm/7.6-5-historical-data-backfill.md](file:///e:/Projects/WorkDataHub/docs/sprint-artifacts/stories/epic-customer-mdm/7.6-5-historical-data-backfill.md)
- [Source: docs/project-context.md](file:///e:/Projects/WorkDataHub/docs/project-context.md)

## Dev Agent Record

### Agent Model Used

{{agent_model_name_version}}

### Debug Log References

### Completion Notes List

### File List
