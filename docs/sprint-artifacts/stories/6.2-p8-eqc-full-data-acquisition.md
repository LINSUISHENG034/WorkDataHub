# Story 6.2-P8: EQC Full Data Acquisition

**Epic:** 6.2 - Generic Reference Data Management
**Type:** Patch Story
**Priority:** High
**Status:** done

## Story

As a **data engineer**,
I want **the EQCClient to support all 3 EQC API endpoints (search, findDepart, findLabels) with `*_with_raw()` variants that return raw JSON for persistence**,
so that **complete enterprise data can be acquired in a single orchestrated call and persisted to the expanded base_info schema for historical analysis**.

## Background & Business Context

### Current State
Story 6.2-P5 implemented EQC data persistence using `search_company_with_raw()` to store the search API response. Story 6.2-P7 expanded the schema to include `raw_business_info` and `raw_biz_label` JSONB columns. However, the EQCClient lacks methods to call the remaining 2 API endpoints that retrieve business details and label information.

### Gap Analysis (from Sprint Change Proposal)

| API Endpoint | URL | Current Status | Required |
|-------------|-----|----------------|----------|
| search | `/kg-api-hfd/api/search/?key={keyword}` | Implemented | `search_company_with_raw()` |
| findDepart | `/kg-api-hfd/api/search/findDepart?targetId={company_id}` | Partial | Need `get_business_info_with_raw()` |
| findLabels | `/kg-api-hfd/api/search/findLabels?targetId={company_id}` | Missing | Need `get_label_info_with_raw()` |

**Important:** `EQCClient.get_company_detail()` already calls the **findDepart** endpoint. This story does **not** change that method; it adds **business_info-specific parsing + raw persistence** and introduces the missing **findLabels** integration.

### Architecture Decision
**Extend EQCClient with new API methods** following existing patterns:
1. Add `get_business_info_with_raw()` - returns both parsed result and raw JSON
2. Add `get_label_info_with_raw()` - returns both parsed result and raw JSON
3. Update `EqcProvider` to orchestrate all 3 API calls and persist raw responses

### Data Flow Architecture

```
EqcProvider.lookup(company_name)
    |
    v
[1] search_company_with_raw(name)  -->  raw_data (JSONB)
    |
    +-- company_id extracted
    |
    v
[2] get_business_info_with_raw(company_id)  -->  raw_business_info (JSONB)
    |                                             (can run in parallel with [3])
[3] get_label_info_with_raw(company_id)     -->  raw_biz_label (JSONB)
    |
    v
upsert_base_info(company_id, raw_data, raw_business_info, raw_biz_label, api_fetched_at=NOW())
```

## Scope

### In Scope
- Add `get_business_info()` method to EQCClient
- Add `get_business_info_with_raw()` method to EQCClient
- Add `get_label_info()` method to EQCClient
- Add `get_label_info_with_raw()` method to EQCClient
- Add domain models: `BusinessInfoResult`, `LabelInfo`
- Update `EqcProvider._cache_result()` to persist `raw_business_info` and `raw_biz_label`
- Update `CompanyMappingRepository.upsert_base_info()` to accept optional `raw_business_info` and `raw_biz_label`
- Add unit tests for new methods
- Add integration tests for full data acquisition flow

### Out of Scope
- Data cleansing rules (Story 6.2-P9)
- CLI commands for batch acquisition (existing `eqc_refresh.py` handles this)
- Business logic changes to enrichment gateway

## Acceptance Criteria

| AC | Description | Priority |
|----|-------------|----------|
| AC1 | `EQCClient.get_business_info(company_id)` returns `BusinessInfoResult` from findDepart API | Required |
| AC2 | `EQCClient.get_business_info_with_raw(company_id)` returns tuple of (BusinessInfoResult, raw_json) | Required |
| AC3 | `EQCClient.get_label_info(company_id)` returns `List[LabelInfo]` from findLabels API | Required |
| AC4 | `EQCClient.get_label_info_with_raw(company_id)` returns tuple of (List[LabelInfo], raw_json) | Required |
| AC5 | All new methods follow existing error handling patterns (EQCAuthenticationError, EQCNotFoundError, etc.) | Required |
| AC6 | All new methods respect rate limiting via `_enforce_rate_limit()` | Required |
| AC7 | `EqcProvider` orchestrates all 3 API calls when looking up a company | Required |
| AC8 | Raw responses persisted to `base_info.raw_business_info` and `base_info.raw_biz_label` | Required |
| AC9 | `api_fetched_at` timestamp updated on successful acquisition | Required |
| AC10 | Unit tests cover all new methods with mocked responses | Required |
| AC11 | Integration test verifies full acquisition flow with real API (optional, requires token) | Optional |

## Hard Constraints (Do Not Violate)

1. **Follow existing EQCClient patterns** - Use `_make_request()` for all HTTP calls, maintain same error handling
2. **Maintain rate limiting** - All API calls must respect the sliding window rate limiter
3. **Security: Never log tokens** - Use `_sanitize_url_for_logging()` for all URL logging
4. **Schema alignment** - `raw_business_info` and `raw_biz_label` store complete API response bodies only (no headers/tokens)
5. **Non-blocking persistence** - Failed persistence should not fail the API call (log and continue)
6. **Maintain backward compatibility** - Existing `search_company()` and `get_company_detail()` unchanged
7. **Type safety** - All new models must use Pydantic v2 with proper validation
8. **Env vars must match code** - Use `WDH_EQC_TOKEN` (required). `WDH_EQC_BASE_URL` is optional. Do not introduce `WDH_PROVIDER_EQC_TOKEN`.
9. **Avoid duplicate findDepart logic** - Reuse the existing request/error-handling skeleton used by `get_company_detail()` (ideally via a shared private helper that returns raw JSON), rather than cloning divergent implementations.
10. **Independent API error handling** - If findDepart succeeds but findLabels fails (or vice versa), persist the successful data; do not discard partial results.

## Tasks / Subtasks

### Phase 1: Domain Models
- [x] Task 1.1: Create `BusinessInfoResult` Pydantic model (AC: #1, #2)
  - [x] Map fields from `businessInfodto` response structure
  - [x] Reference Story 6.2-P7 `business_info Column Map` for complete 40-field mapping
  - [x] Add proper validators for critical fields (company_id required, dates optional)
- [x] Task 1.2: Create `LabelInfo` Pydantic model (AC: #3, #4)
  - [x] Map fields from `labels` response structure
  - [x] Include: `type`, `company_id`, `lv1_name` through `lv4_name`
  - [x] Handle null `companyId` with sibling fallback (per Legacy pattern)

### Phase 2: EQCClient Methods
- [x] Task 2.1: Implement `get_business_info()` (AC: #1, #5, #6)
  - [x] Call `/kg-api-hfd/api/search/findDepart?targetId={company_id}`
  - [x] Parse `businessInfodto` from response
  - [x] **CRITICAL**: Extract shared helper `_fetch_find_depart(company_id) -> tuple[dict, dict]` to avoid code duplication with `get_company_detail()` (see Dev Notes for pattern)
  - [x] Return `BusinessInfoResult` or raise appropriate exception
- [x] Task 2.2: Implement `get_business_info_with_raw()` (AC: #2)
  - [x] Same as 2.1 but also return raw JSON dict
  - [x] Follow pattern from `search_company_with_raw()`
- [x] Task 2.3: Implement `get_label_info()` (AC: #3, #5, #6)
  - [x] Call `/kg-api-hfd/api/search/findLabels?targetId={company_id}`
  - [x] Parse `labels` array from response
  - [x] Apply `parse_label_info()` logic from Legacy crawler
  - [x] Return `List[LabelInfo]`
- [x] Task 2.4: Implement `get_label_info_with_raw()` (AC: #4)
  - [x] Same as 2.3 but also return raw JSON dict

### Phase 3: Provider Integration
- [x] Task 3.1: Update `EqcProvider._call_api()` to orchestrate 3 calls (AC: #7)
  - [x] After successful search: call findDepart and findLabels
  - [x] Store all raw responses for persistence
  - [x] Budget: do **not** introduce additional budget decrements; keep the existing "1 lookup = 1 budget unit" behavior (detail calls are included in that lookup)
  - [x] **Error isolation**: If findDepart fails, still attempt findLabels (and vice versa)
- [x] Task 3.2: Update `EqcProvider._cache_result()` for full persistence (AC: #8, #9)
  - [x] Pass `raw_business_info` and `raw_biz_label` to repository
  - [x] `api_fetched_at` is updated automatically by repository SQL (see Task 3.3)
- [x] Task 3.3: Update `CompanyMappingRepository.upsert_base_info()` (AC: #8, #9)
  - [x] Add optional `raw_business_info: Optional[dict] = None` parameter
  - [x] Add optional `raw_biz_label: Optional[dict] = None` parameter
  - [x] **CRITICAL SQL change**: Update INSERT and ON CONFLICT DO UPDATE to include:
    ```sql
    INSERT INTO enterprise.base_info
        (company_id, search_key_word, "companyFullName", unite_code,
         raw_data, raw_business_info, raw_biz_label, api_fetched_at, updated_at)
    VALUES
        (:company_id, :search_key_word, :company_full_name, :unite_code,
         CAST(:raw_data AS JSONB), CAST(:raw_business_info AS JSONB),
         CAST(:raw_biz_label AS JSONB), NOW(), NOW())
    ON CONFLICT (company_id) DO UPDATE SET
        search_key_word = COALESCE(EXCLUDED.search_key_word, enterprise.base_info.search_key_word),
        "companyFullName" = COALESCE(EXCLUDED."companyFullName", enterprise.base_info."companyFullName"),
        unite_code = COALESCE(EXCLUDED.unite_code, enterprise.base_info.unite_code),
        raw_data = COALESCE(EXCLUDED.raw_data, enterprise.base_info.raw_data),
        raw_business_info = COALESCE(EXCLUDED.raw_business_info, enterprise.base_info.raw_business_info),
        raw_biz_label = COALESCE(EXCLUDED.raw_biz_label, enterprise.base_info.raw_biz_label),
        api_fetched_at = NOW(),
        updated_at = NOW()
    ```
  - [x] Use COALESCE to preserve existing data if new value is NULL (partial update support)

### Phase 4: Testing
- [x] Task 4.1: Add unit tests for `get_business_info()` (AC: #10)
  - [x] Mock successful response, verify parsing
  - [x] Mock 404 response, verify EQCNotFoundError
  - [x] Mock 401 response, verify EQCAuthenticationError
- [x] Task 4.2: Add unit tests for `get_label_info()` (AC: #10)
  - [x] Mock successful response with multiple labels
  - [x] Test null companyId fallback logic
  - [x] Mock empty labels array
- [x] Task 4.3: Add integration test for full acquisition flow (AC: #11)
  - [x] Optional: requires `WDH_EQC_TOKEN`, `WDH_TEST_DATABASE_URI` and explicit opt-in `RUN_EQC_INTEGRATION_TESTS=1`
  - [x] Verify all 3 API calls executed
  - [x] Verify raw data persisted to database
- [x] Task 4.4: Add unit tests for provider orchestration
  - [x] Test partial failure (findDepart OK, findLabels fails)
  - [x] Test budget not decremented for detail calls

## Dev Notes

### Code Reuse Pattern for findDepart (MUST FOLLOW)

To avoid duplicating findDepart logic between `get_company_detail()` and `get_business_info()`:

```python
# In eqc_client.py - extract shared private helper

def _fetch_find_depart(self, company_id: str) -> tuple[dict, dict]:
    """
    Call findDepart API and return (businessInfodto, raw_response).

    Shared by get_company_detail() and get_business_info_with_raw().
    Handles rate limiting, error handling, and logging internally.

    Returns:
        Tuple of (businessInfodto dict, complete raw response dict)

    Raises:
        EQCNotFoundError: If company not found (404 or empty businessInfodto)
        EQCAuthenticationError: If token invalid (401)
        EQCClientError: For other errors
    """
    url = f"{self.base_url}/kg-api-hfd/api/search/findDepart"
    params = {"targetId": company_id}

    response = self._make_request("GET", url, params=params)
    data = response.json()

    business_info = data.get("businessInfodto", {})
    if not business_info:
        raise EQCNotFoundError(f"No business info for company: {company_id}")

    return business_info, data

# Then refactor existing method:
def get_company_detail(self, company_id: str) -> CompanyDetail:
    business_info, _ = self._fetch_find_depart(company_id)
    return self._parse_company_detail(business_info)

# And add new method:
def get_business_info_with_raw(self, company_id: str) -> tuple[BusinessInfoResult, dict]:
    business_info, raw = self._fetch_find_depart(company_id)
    return self._parse_business_info(business_info), raw
```

### BusinessInfoResult Field Mapping (Reference Story 6.2-P7)

The `BusinessInfoResult` model should include fields that map to `enterprise.business_info` table columns from Story 6.2-P7:

| API Field (businessInfodto) | Model Field | Type | Notes |
|----------------------------|-------------|------|-------|
| `company_id` | `company_id` | str | Required, PK |
| `company_name` | `company_name` | str | |
| `registered_date` | `registered_date` | Optional[str] | Raw string, cleansed in P9 |
| `registerCaptial` | `registered_capital_raw` | Optional[str] | Raw "80000.00万元", cleansed in P9 |
| `registered_status` | `registered_status` | Optional[str] | |
| `legal_person_name` | `legal_person_name` | Optional[str] | |
| `address` | `address` | Optional[str] | |
| `credit_code` | `credit_code` | Optional[str] | 统一社会信用代码 |
| `company_type` | `company_type` | Optional[str] | |
| `industry_name` | `industry_name` | Optional[str] | |
| `business_scope` | `business_scope` | Optional[str] | |
| ... | ... | ... | See Story 6.2-P7 for full 40-field list |

**Note:** Store raw string values; cleansing (DATE parsing, NUMERIC conversion) is Story 6.2-P9 scope.

### LabelInfo Model Structure

```python
class LabelInfo(BaseModel):
    """Single label entry from findLabels API."""

    model_config = ConfigDict(str_strip_whitespace=True, extra="forbid")

    company_id: str = Field(..., description="Company ID (may need sibling fallback)")
    type: str = Field(..., description="Label category (e.g., '行业分类')")
    lv1_name: Optional[str] = Field(None, alias="lv1Name")
    lv2_name: Optional[str] = Field(None, alias="lv2Name")
    lv3_name: Optional[str] = Field(None, alias="lv3Name")
    lv4_name: Optional[str] = Field(None, alias="lv4Name")
```

### Key Files to Modify

| File | Change |
|------|--------|
| `src/work_data_hub/domain/company_enrichment/models.py` | Add `BusinessInfoResult`, `LabelInfo` models |
| `src/work_data_hub/io/connectors/eqc_client.py` | Add 4 new methods + `_fetch_find_depart` helper |
| `src/work_data_hub/infrastructure/enrichment/eqc_provider.py` | Update `_call_api()`, `_cache_result()` |
| `src/work_data_hub/infrastructure/enrichment/mapping_repository.py` | Update `upsert_base_info()` signature + SQL |
| `tests/io/connectors/test_eqc_client.py` | Add unit tests (create if not exists) |
| `tests/unit/infrastructure/enrichment/test_eqc_provider.py` | Add unit tests (create if not exists) |
| `tests/integration/infrastructure/enrichment/test_eqc_data_persistence_integration.py` | Extend integration coverage |

**Note on test paths:** If any test file doesn't exist, create it following existing test patterns in the repository.

### Existing Code Patterns to Follow

**From EQCClient (search_company_with_raw pattern):**
```python
def search_company_with_raw(self, name: str) -> tuple[List[CompanySearchResult], dict]:
    """Return both parsed results and raw JSON."""
    # ... implementation
    return companies, data  # (parsed, raw)
```

**From EqcProvider._cache_result (persistence pattern):**
```python
def _cache_result(self, company_name: str, result: CompanyInfo, raw_json: Optional[dict] = None):
    # Non-blocking persistence - failure must not fail the lookup
    try:
        self.mapping_repository.upsert_base_info(
            company_id=result.company_id,
            search_key_word=company_name,
            company_full_name=result.official_name,
            unite_code=result.unified_credit_code,
            raw_data=raw_json,
        )
    except Exception as e:
        logger.warning("Failed to persist - continuing", error_type=type(e).__name__)
```

### Previous Story Learnings (from 6.2-P7)

1. **Schema is ready** - `base_info` already has `raw_business_info` and `raw_biz_label` columns
2. **JSONB storage** - Store complete response body only, no headers/tokens
3. **Timestamps** - Always update `api_fetched_at` on successful API call
4. **Idempotent operations** - UPSERT pattern for all persistence

### Git Intelligence (Recent Commits)

| Commit | Relevance |
|--------|-----------|
| `fd31237` | Story 6.2-P7 - Schema consolidation completed, columns ready |
| `e36f81c` | Story 6.2-P5 - `search_company_with_raw()` pattern established |

### Project Structure Notes

- EQCClient: `src/work_data_hub/io/connectors/eqc_client.py` (IO layer - HTTP client)
- EqcProvider: `src/work_data_hub/infrastructure/enrichment/eqc_provider.py` (Infrastructure layer - business logic)
- Models: `src/work_data_hub/domain/company_enrichment/models.py` (Domain layer - data contracts)
- Repository: `src/work_data_hub/infrastructure/enrichment/mapping_repository.py` (Infrastructure layer - persistence)

### Critical Implementation Notes (Disaster Prevention)

1. **Rate limiting applies to ALL API calls** - findDepart and findLabels must use `_enforce_rate_limit()`
2. **Budget is per lookup** - keep existing `EqcProvider` "1 lookup = 1 decrement" behavior; do not add extra decrements for detail calls
3. **Handle empty responses** - `businessInfodto` or `labels` may be null/empty
4. **Preserve existing behavior** - Don't change existing `get_company_detail()` method's return type or signature
5. **Test with mock data first** - Real API testing requires valid token
6. **Env vars** - Use `WDH_EQC_TOKEN` and optional `WDH_EQC_BASE_URL` (align with `SettingsConfigDict(env_prefix="WDH_")`)
7. **Partial success handling** - If search succeeds but findDepart/findLabels fail, persist what you have

## Testing / Validation

### Unit Tests (Must)

1. `test_get_business_info_success`:
   - Mock findDepart response with full businessInfodto
   - Verify all fields parsed correctly into BusinessInfoResult

2. `test_get_business_info_not_found`:
   - Mock 404 response
   - Verify EQCNotFoundError raised

3. `test_get_business_info_with_raw`:
   - Verify returns tuple of (result, raw_json)
   - Verify raw_json contains complete response body

4. `test_get_label_info_success`:
   - Mock findLabels response with multiple label types
   - Verify all labels parsed correctly

5. `test_get_label_info_null_company_id_fallback`:
   - Mock response with null companyId in some labels
   - Verify sibling fallback logic works

6. `test_get_label_info_empty`:
   - Mock response with empty labels array
   - Verify returns empty list (not error)

7. `test_provider_orchestrates_three_apis`:
   - Mock all 3 API calls
   - Verify upsert_base_info called with all 3 raw payloads

8. `test_provider_partial_failure`:
   - Mock search + findDepart success, findLabels failure
   - Verify partial data still persisted

**Pytest Markers (align with repo conventions):**
- Mark pure connector tests as `@pytest.mark.unit`
- Mark DB-backed tests as `@pytest.mark.integration`

### Integration Validation (Optional - requires token)

```bash
# Test full acquisition flow
# Required: WDH_EQC_TOKEN in `.wdh_env` (or environment); optional: WDH_EQC_BASE_URL
PYTHONPATH=src uv run --env-file .wdh_env python -c "
from work_data_hub.io.connectors.eqc_client import EQCClient

client = EQCClient()
results, search_raw = client.search_company_with_raw('中国平安')
if results:
    company_id = results[0].company_id
    business_info, business_raw = client.get_business_info_with_raw(company_id)
    labels, labels_raw = client.get_label_info_with_raw(company_id)
    print(f'Business: {business_info.company_id if business_info else None}')
    print(f'Labels: {len(labels)} items')
    print(f'Raw business keys: {list(business_raw.keys()) if business_raw else None}')
"
```

## Definition of Done

- [x] All REQUIRED ACs satisfied
- [x] `BusinessInfoResult` and `LabelInfo` models created with proper validation
- [x] `get_business_info()` and `get_business_info_with_raw()` implemented
- [x] `get_label_info()` and `get_label_info_with_raw()` implemented
- [x] `_fetch_find_depart()` helper extracted to avoid code duplication
- [x] All methods follow existing EQCClient patterns
- [x] `EqcProvider` orchestrates all 3 API calls
- [x] `upsert_base_info()` accepts and persists `raw_business_info`, `raw_biz_label`, and updates `api_fetched_at`
- [x] Unit tests added and passing
- [x] Targeted EQC unit tests pass (no regressions)
- [x] Code follows project conventions (KISS, YAGNI)

## References

- Sprint Change Proposal: `docs/sprint-artifacts/sprint-change-proposal/sprint-change-proposal-2025-12-14-eqc-api-full-coverage.md`
- Sprint Status: `docs/sprint-artifacts/sprint-status.yaml`
- Previous Story (Schema): `docs/sprint-artifacts/stories/6.2-p7-enterprise-schema-consolidation.md`
- Legacy Crawler: `legacy/annuity_hub/crawler/eqc_crawler.py`
- EQCClient: `src/work_data_hub/io/connectors/eqc_client.py`
- EqcProvider: `src/work_data_hub/infrastructure/enrichment/eqc_provider.py`
- Architecture: `docs/architecture/technology-stack.md`
- Architecture: `docs/architecture/implementation-patterns.md`
- Architecture: `docs/architecture/architectural-decisions.md`

## Appendix

### Appendix A: API Response Shapes

**findDepart Response (`businessInfodto`):**
```json
{
  "businessInfodto": {
    "company_id": "12345",
    "company_name": "中国平安保险(集团)股份有限公司",
    "registered_date": "1988-03-21",
    "registerCaptial": "80000.00万元",
    "registered_status": "存续",
    "legal_person_name": "马明哲",
    "address": "深圳市福田区...",
    "credit_code": "91440300...",
    "company_type": "股份有限公司",
    "industry_name": "保险业",
    "business_scope": "..."
  }
}
```

**findLabels Response:**
```json
{
  "labels": [
    {
      "type": "行业分类",
      "labels": [
        {"companyId": "12345", "lv1Name": "金融业", "lv2Name": "保险业", "lv3Name": "人身保险", "lv4Name": null}
      ]
    }
  ]
}
```

### Appendix B: Label Parsing with Null companyId Fallback

```python
# From legacy/annuity_hub/crawler/eqc_crawler.py:parse_label_info
# When companyId is None, search siblings for a non-null value
def parse_labels_with_fallback(labels_response: dict, target_company_id: str) -> List[LabelInfo]:
    results = []
    for category in labels_response.get("labels", []):
        label_type = category.get("type", "")
        for lab in category.get("labels", []):
            company_id = lab.get("companyId")
            # Fallback: if companyId is None, try siblings
            if company_id is None:
                for sibling in category.get("labels", []):
                    if sibling.get("companyId"):
                        company_id = sibling["companyId"]
                        break
            # Final fallback: use the target_company_id from search
            if company_id is None:
                company_id = target_company_id

            results.append(LabelInfo(
                company_id=company_id,
                type=label_type,
                lv1_name=lab.get("lv1Name"),
                lv2_name=lab.get("lv2Name"),
                lv3_name=lab.get("lv3Name"),
                lv4_name=lab.get("lv4Name"),
            ))
    return results
```

## Dev Agent Record

### Context Reference

- Sprint Change Proposal: `docs/sprint-artifacts/sprint-change-proposal/sprint-change-proposal-2025-12-14-eqc-api-full-coverage.md`
- Previous Story P7 Learnings: Schema ready with `raw_business_info` and `raw_biz_label` columns

### Agent Model Used

GPT-5.2 (Codex CLI)

### Debug Log References

N/A

### Completion Notes List

- Fixed findDepart parsing robustness and error surfacing for `BusinessInfoResult`.
- Ensured label parsing handles null companyId sibling fallback + region label normalization.
- Updated base_info upsert to include metadata COALESCE on conflict.
- Updated tests to reflect actual HTTP call signature (`timeout=`) and normalized error messages.
- Test run: `python -m pytest -q tests/io/connectors/test_eqc_client.py tests/unit/infrastructure/enrichment/test_eqc_provider.py` (81 passed, 1 skipped)
- Live EQC integration test (opt-in): `python -m pytest -q -m eqc_integration` (requires `RUN_EQC_INTEGRATION_TESTS=1`)

### File List

- `src/work_data_hub/domain/company_enrichment/models.py`
- `src/work_data_hub/io/connectors/eqc_client.py`
- `src/work_data_hub/infrastructure/enrichment/eqc_provider.py`
- `src/work_data_hub/infrastructure/enrichment/mapping_repository.py`
- `src/work_data_hub/io/connectors/__init__.py`
- `src/work_data_hub/infrastructure/enrichment/__init__.py`
- `tests/io/connectors/test_eqc_client.py`
- `tests/unit/infrastructure/enrichment/test_eqc_provider.py`
- `tests/integration/infrastructure/enrichment/test_eqc_full_data_acquisition_eqc_integration.py`
- `tests/conftest.py`
- `pyproject.toml`
- `readline.py`
- `docs/sprint-artifacts/sprint-status.yaml`
- `docs/sprint-artifacts/stories/6.2-p8-eqc-full-data-acquisition.md`

---

## SM Review Record

### Review Date
2025-12-15

### Reviewer
Claude Opus 4.5 (SM Agent - validate-create-story)

### Issues Found & Fixed

| # | Category | Issue | Fix Applied |
|---|----------|-------|-------------|
| C1 | Critical | `upsert_base_info()` SQL missing new columns | Added complete SQL with `raw_business_info`, `raw_biz_label`, `api_fetched_at`, and COALESCE for partial updates |
| C2 | Critical | Code duplication risk for findDepart | Added `_fetch_find_depart()` helper pattern in Dev Notes |
| C3 | Critical | `BusinessInfoResult` field mapping incomplete | Added field mapping table referencing Story 6.2-P7 |
| E1 | Enhancement | Test file paths may not exist | Added note to create if not exists |
| E2 | Enhancement | `api_fetched_at` update location unclear | Clarified in Task 3.3 SQL (NOW() in repository) |
| E3 | Enhancement | Batch/parallel call guidance missing | Added Data Flow Architecture diagram |
| E4 | Enhancement | Partial failure handling unclear | Added Hard Constraint #10 and Task 3.1 error isolation guidance |
| O1 | Optimization | Verbose appendix | Consolidated and compacted |
| O2 | Optimization | Missing visual architecture | Added Data Flow diagram |

### Validation Outcome

**APPROVED** - All critical issues addressed, story is ready for dev-story execution.

---

## Senior Developer Review (AI)

**Date:** 2025-12-15
**Reviewer:** GPT-5.2 (Codex CLI)
**Outcome:** ✅ APPROVED - Changes Applied

### Findings Summary

**Fixed Issues:** 3 HIGH, 4 MEDIUM, 2 LOW

**Highlights:**
- Hardened findDepart parsing to avoid mismatched response keys causing Pydantic validation failures.
- Fixed LabelInfo construction to support `populate_by_name` and normalized a common "地区分类" shape to expected hierarchy.
- Updated `upsert_base_info()` conflict update to include metadata columns (COALESCE) and removed repository logging of `company_id` (per repo contract).
- Unblocked test execution on Windows by making package `__init__` imports lazy and avoiding problematic readline/WMI import side-effects during pytest startup/collection.

## Change Log

| Date | Author | Change |
|------|--------|--------|
| 2025-12-15 | SM Agent (GPT-5.2) | Initial story creation via create-story workflow |
| 2025-12-15 | SM Agent (Claude Opus 4.5) | Validation review: Fixed 3 critical issues, 4 enhancements, 2 optimizations |
| 2025-12-15 | Code Review (GPT-5.2) | Adversarial review fixes: hardened parsing, updated persistence SQL, fixed tests, and improved testability via lazy imports |
